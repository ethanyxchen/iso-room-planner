{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 10, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethanchen/Projects/hackajohn/packages/isometric-city/src/components/game/types.ts"],"sourcesContent":["// Game-specific types for rendering and animation\n\nimport { CardinalDirection } from '@/core/types';\n\n// Isometric tile dimensions\nexport const TILE_WIDTH = 64;\nexport const HEIGHT_RATIO = 0.60;\nexport const TILE_HEIGHT = TILE_WIDTH * HEIGHT_RATIO;\nexport const KEY_PAN_SPEED = 520;\n\n// Car/Vehicle types - alias CardinalDirection for backward compatibility\nexport type CarDirection = CardinalDirection;\n\nexport type Car = {\n  id: number;\n  tileX: number;\n  tileY: number;\n  direction: CarDirection;\n  progress: number;\n  speed: number;\n  age: number;\n  maxAge: number;\n  color: string;\n  laneOffset: number;\n};\n\nexport type Bus = {\n  id: number;\n  tileX: number;\n  tileY: number;\n  direction: CarDirection;\n  progress: number;\n  speed: number;\n  age: number;\n  maxAge: number;\n  color: string;\n  laneOffset: number;\n  path: { x: number; y: number }[];\n  pathIndex: number;\n  stopTimer: number;\n  stops: { x: number; y: number }[];\n};\n\n// Airplane types for airport animation\nexport type AirplaneState = 'flying' | 'landing' | 'taking_off' | 'taxiing';\n\n// Plane model types from the sprite sheet\nexport type PlaneType = '737' | '777' | '747' | 'a380' | 'g650' | 'seaplane';\n\nexport type ContrailParticle = {\n  x: number;\n  y: number;\n  age: number;\n  opacity: number;\n};\n\nexport type Airplane = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Flight direction in radians\n  angle: number;\n  // Current state\n  state: AirplaneState;\n  // Speed (pixels per second in screen space)\n  speed: number;\n  // Altitude (0 = ground, 1 = cruising altitude) - affects scale and shadow\n  altitude: number;\n  // Target altitude for transitions\n  targetAltitude: number;\n  // Airport tile coordinates (for landing/takeoff reference)\n  airportX: number;\n  airportY: number;\n  // Progress for landing/takeoff (0-1)\n  stateProgress: number;\n  // Contrail particles\n  contrail: ContrailParticle[];\n  // Time until despawn (for flying planes)\n  lifeTime: number;\n  // Plane color/style (legacy, for fallback rendering)\n  color: string;\n  // Plane model type from sprite sheet\n  planeType: PlaneType;\n};\n\n// Seaplane types for bay/water operations\nexport type SeaplaneState = 'taxiing_water' | 'taxiing_to_dock' | 'docked' | 'taking_off' | 'flying' | 'landing' | 'splashdown';\n\nexport type Seaplane = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Flight/movement direction in radians\n  angle: number;\n  // Target angle for smooth turning (on water)\n  targetAngle: number;\n  // Current state\n  state: SeaplaneState;\n  // Speed (pixels per second in screen space)\n  speed: number;\n  // Altitude (0 = on water, 1 = cruising altitude)\n  altitude: number;\n  // Target altitude for transitions\n  targetAltitude: number;\n  // Bay tile coordinates (home bay for landing reference)\n  bayTileX: number;\n  bayTileY: number;\n  // Bay screen position (center of bay)\n  bayScreenX: number;\n  bayScreenY: number;\n  // Progress for state transitions\n  stateProgress: number;\n  // Contrail particles (when flying at altitude)\n  contrail: ContrailParticle[];\n  // Wake particles (when on water)\n  wake: WakeParticle[];\n  // Wake spawn progress\n  wakeSpawnProgress: number;\n  // Time until state change\n  lifeTime: number;\n  // Time spent taxiing on water before takeoff\n  taxiTime: number;\n  // Seaplane color/style\n  color: string;\n  // Dock target (marina/pier) - null if no dock in bay\n  dockTileX: number | null;\n  dockTileY: number | null;\n  dockScreenX: number | null;\n  dockScreenY: number | null;\n  // Time spent docked\n  dockTime: number;\n  // Number of flights completed (for cycle tracking)\n  flightCount: number;\n};\n\n// Helicopter types for hospital/airport transport\nexport type HelicopterState = 'flying' | 'hovering' | 'landing' | 'taking_off';\n\nexport type RotorWashParticle = {\n  x: number;\n  y: number;\n  age: number;\n  opacity: number;\n};\n\nexport type Helicopter = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Flight direction in radians\n  angle: number;\n  // Current state\n  state: HelicopterState;\n  // Speed (pixels per second in screen space)\n  speed: number;\n  // Altitude (0 = ground, 0.5 = cruising for helicopters)\n  altitude: number;\n  // Target altitude for transitions\n  targetAltitude: number;\n  // Origin heliport (hospital, airport, police, or mall) tile coordinates\n  originX: number;\n  originY: number;\n  originType: 'hospital' | 'airport' | 'police' | 'mall';\n  // Destination heliport tile coordinates\n  destX: number;\n  destY: number;\n  destType: 'hospital' | 'airport' | 'police' | 'mall';\n  // Destination screen position\n  destScreenX: number;\n  destScreenY: number;\n  // Progress for state transitions\n  stateProgress: number;\n  // Rotor wash/exhaust particles (small contrails)\n  rotorWash: RotorWashParticle[];\n  // Rotor animation angle\n  rotorAngle: number;\n  // Helicopter color/style\n  color: string;\n  // Searchlight properties (active at night)\n  searchlightAngle: number; // Current angle of the searchlight sweep (radians)\n  searchlightSweepSpeed: number; // How fast the light sweeps (radians per second)\n  searchlightSweepRange: number; // Max angle deviation from center (radians)\n  searchlightBaseAngle: number; // Base direction of the searchlight sweep\n};\n\n// Emergency vehicle types\nexport type EmergencyVehicleType = 'fire_truck' | 'police_car';\nexport type EmergencyVehicleState = 'dispatching' | 'responding' | 'returning';\n\nexport type EmergencyVehicle = {\n  id: number;\n  type: EmergencyVehicleType;\n  tileX: number;\n  tileY: number;\n  direction: CarDirection;\n  progress: number;\n  speed: number;\n  state: EmergencyVehicleState;\n  stationX: number;\n  stationY: number;\n  targetX: number;\n  targetY: number;\n  path: { x: number; y: number }[];\n  pathIndex: number;\n  respondTime: number; // Time spent at the scene\n  laneOffset: number;\n  flashTimer: number; // For emergency light animation\n};\n\n// Pedestrian types, destinations, and behaviors\nexport type PedestrianDestType = 'school' | 'commercial' | 'industrial' | 'park' | 'beach' | 'home';\n\n// Pedestrian behavioral states\nexport type PedestrianState =\n  | 'walking'           // Walking along a path\n  | 'approaching_shop'  // Walking up to a shop entrance (visible at door)\n  | 'entering_building' // Entering a building (walking through door)\n  | 'inside_building'   // Inside a building (invisible)\n  | 'exiting_building'  // Exiting a building (walking out of door)\n  | 'at_recreation'     // At a recreational area doing an activity\n  | 'at_beach'          // At the beach (swimming or on mat)\n  | 'idle'              // Standing still, waiting\n  | 'socializing';      // Chatting with other pedestrians\n\n// Activities pedestrians can do at recreation areas\nexport type PedestrianActivity =\n  | 'none'\n  | 'playing_basketball'\n  | 'playing_tennis'\n  | 'playing_soccer'\n  | 'playing_baseball'\n  | 'swimming'\n  | 'beach_swimming'\n  | 'lying_on_mat'\n  | 'skateboarding'\n  | 'sitting_bench'\n  | 'picnicking'\n  | 'walking_dog'\n  | 'jogging'\n  | 'playground'\n  | 'watching_game'\n  | 'shopping'\n  | 'working'\n  | 'studying';\n\n// Recreation area types with their associated activities\nexport type RecreationAreaType =\n  | 'basketball_court'\n  | 'tennis_court'\n  | 'soccer_field'\n  | 'baseball_field'\n  | 'swimming_pool'\n  | 'skate_park'\n  | 'park_bench'\n  | 'playground'\n  | 'stadium_seating'\n  | 'generic_park';\n\nexport type Pedestrian = {\n  id: number;\n  tileX: number;\n  tileY: number;\n  direction: CarDirection;\n  progress: number;\n  speed: number;\n  age: number;\n  maxAge: number;\n  skinColor: string;\n  shirtColor: string;\n  pantsColor: string;        // NEW: pants/shorts color\n  hasHat: boolean;           // NEW: wearing a hat\n  hatColor: string;          // NEW: hat color\n  walkOffset: number;        // For walking animation\n  sidewalkSide: 'left' | 'right';\n  destType: PedestrianDestType;\n  homeX: number;\n  homeY: number;\n  destX: number;\n  destY: number;\n  returningHome: boolean;\n  path: { x: number; y: number }[];\n  pathIndex: number;\n  // NEW: Dynamic behavior properties\n  state: PedestrianState;\n  activity: PedestrianActivity;\n  activityProgress: number;  // 0-1 progress through current activity\n  activityDuration: number;  // How long to stay at current activity (seconds)\n  buildingEntryProgress: number; // 0-1 for enter/exit animations\n  socialTarget: number | null;   // ID of pedestrian we're socializing with\n  // Position offset within activity area (for varied positioning)\n  activityOffsetX: number;\n  activityOffsetY: number;\n  // Animation state for activities\n  activityAnimTimer: number;\n  // Items the pedestrian might have\n  hasBall: boolean;          // Carrying a ball\n  hasDog: boolean;           // Walking a dog\n  hasBag: boolean;           // Shopping bag or briefcase\n  // Beach-specific properties\n  hasBeachMat: boolean;      // Has a beach mat\n  matColor: string;          // Color of the beach mat\n  beachTileX: number;        // Beach water tile X (for swimming position)\n  beachTileY: number;        // Beach water tile Y (for swimming position)\n  beachEdge: 'north' | 'east' | 'south' | 'west' | null; // Which edge of water tile is beach\n};\n\n// Boat types for water navigation\nexport type BoatState = 'sailing' | 'docked' | 'arriving' | 'departing' | 'touring';\n\nexport type WakeParticle = {\n  x: number;\n  y: number;\n  age: number;\n  opacity: number;\n};\n\nexport type TourWaypoint = {\n  screenX: number;\n  screenY: number;\n  tileX: number;\n  tileY: number;\n};\n\nexport type Boat = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Movement direction in radians\n  angle: number;\n  // Target angle for smooth turning\n  targetAngle: number;\n  // Current state\n  state: BoatState;\n  // Speed (pixels per second in screen space)\n  speed: number;\n  // Origin marina/pier tile coordinates (home dock)\n  originX: number;\n  originY: number;\n  // Destination marina/pier tile coordinates\n  destX: number;\n  destY: number;\n  // Screen position of destination\n  destScreenX: number;\n  destScreenY: number;\n  // Lifetime/age tracking\n  age: number;\n  // Boat color/style\n  color: string;\n  // Wake particles (similar to plane contrails)\n  wake: WakeParticle[];\n  // Progress for wake spawning\n  wakeSpawnProgress: number;\n  // Boat size variant (0 = small, 1 = medium)\n  sizeVariant: number;\n  // Tour waypoints - points to visit during tour before returning to dock\n  tourWaypoints: TourWaypoint[];\n  // Current waypoint index in tour\n  tourWaypointIndex: number;\n  // Home dock screen position (for return trip)\n  homeScreenX: number;\n  homeScreenY: number;\n};\n\n// Barge types for ocean cargo transport\nexport type BargeState = 'approaching' | 'docking' | 'docked' | 'departing' | 'leaving';\n\nexport type Barge = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Movement direction in radians\n  angle: number;\n  // Target angle for smooth turning\n  targetAngle: number;\n  // Current state\n  state: BargeState;\n  // Speed (pixels per second in screen space) - slower than boats\n  speed: number;\n  // Spawn edge of the map ('north' | 'south' | 'east' | 'west')\n  spawnEdge: 'north' | 'south' | 'east' | 'west';\n  // Spawn point (screen coordinates)\n  spawnScreenX: number;\n  spawnScreenY: number;\n  // Target marina tile coordinates\n  targetMarinaX: number;\n  targetMarinaY: number;\n  // Screen position of target marina\n  targetScreenX: number;\n  targetScreenY: number;\n  // Lifetime/age tracking\n  age: number;\n  // Barge color/style\n  color: string;\n  // Wake particles (larger than boats)\n  wake: WakeParticle[];\n  // Progress for wake spawning\n  wakeSpawnProgress: number;\n  // Cargo type for visual variety (0 = containers, 1 = bulk, 2 = tanker)\n  cargoType: number;\n  // Economic value delivered when docked\n  cargoValue: number;\n  // Time spent docked (for loading/unloading)\n  dockTime: number;\n  // Max dock time before departing\n  maxDockTime: number;\n};\n\n// Smog/smoke particle types for industrial factories\nexport type SmogParticle = {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  age: number;\n  maxAge: number;\n  size: number;\n  opacity: number;\n};\n\nexport type FactorySmog = {\n  tileX: number;\n  tileY: number;\n  screenX: number;\n  screenY: number;\n  buildingType: 'factory_medium' | 'factory_large';\n  particles: SmogParticle[];\n  spawnTimer: number;\n};\n\n// Firework types for nighttime celebrations at stadiums, amusement parks, and marinas\nexport type FireworkState = 'launching' | 'exploding' | 'fading';\n\nexport type FireworkParticle = {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  age: number;\n  maxAge: number;\n  color: string;\n  size: number;\n  trail: { x: number; y: number; age: number }[];\n};\n\nexport type Firework = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Velocity\n  vx: number;\n  vy: number;\n  // Current state\n  state: FireworkState;\n  // Launch target height (screen Y when it should explode)\n  targetY: number;\n  // Color for this firework\n  color: string;\n  // Explosion particles\n  particles: FireworkParticle[];\n  // Age tracking\n  age: number;\n  // Source building tile\n  sourceTileX: number;\n  sourceTileY: number;\n};\n\n// Cloud types for atmospheric effects - distinct meteorological cloud types\nexport type CloudType =\n  | 'cumulus'       // Fluffy fair-weather clouds\n  | 'stratus'       // Flat, layered overcast\n  | 'cirrus'        // Wispy high-altitude\n  | 'cumulonimbus'  // Towering storm clouds (dark base, white top)\n  | 'altocumulus';  // Mid-level patchy mackerel sky\n\nexport type CloudPuff = {\n  // Offset from cloud center (for multi-puff clouds)\n  offsetX: number;\n  offsetY: number;\n  // Size of this puff (radius)\n  size: number;\n  // Opacity multiplier\n  opacity: number;\n  // Stretch for non-circular puffs: 1=round, >1=elongated (stratus: wide/flat, cirrus: wispy)\n  stretchX?: number;\n  stretchY?: number;\n  // For cumulonimbus: 'base' (dark) or 'top' (bright) - undefined = use cloud default\n  portion?: 'base' | 'top';\n};\n\nexport type Cloud = {\n  id: number;\n  // Screen position (isometric coordinates)\n  x: number;\n  y: number;\n  // Velocity (pixels per second)\n  vx: number;\n  vy: number;\n  // Cloud size scale (1.0 = normal)\n  scale: number;\n  // Base opacity (0-1)\n  opacity: number;\n  // Array of puffs that make up this cloud\n  puffs: CloudPuff[];\n  // Altitude layer (0 = low, 1 = mid, 2 = high) - affects parallax\n  layer: number;\n  // Meteorological cloud type - determines shape, color, and rendering\n  cloudType: CloudType;\n};\n\n// Direction metadata - re-export from core\nexport type { DirectionMeta } from '@/core/types/grid';\n\n// World render state\nexport type WorldRenderState = {\n  grid: import('@/types/game').Tile[][];\n  gridSize: number;\n  offset: { x: number; y: number };\n  zoom: number;\n  speed: number;\n  canvasSize: { width: number; height: number };\n};\n\n// Overlay modes for visualization\nexport type OverlayMode = 'none' | 'power' | 'water' | 'fire' | 'police' | 'health' | 'education' | 'subway';\n\n// ============================================================================\n// Train Types\n// ============================================================================\n\n/** Train carriage type */\nexport type CarriageType = 'locomotive' | 'passenger' | 'freight_box' | 'freight_tank' | 'freight_flat' | 'caboose';\n\n/** Train type (passenger or freight) */\nexport type TrainType = 'passenger' | 'freight';\n\n/** Smoke particle for freight train locomotives */\nexport type TrainSmokeParticle = {\n  x: number;\n  y: number;\n  vx: number;\n  vy: number;\n  age: number;\n  maxAge: number;\n  size: number;\n  opacity: number;\n};\n\n/** Individual train carriage */\nexport type TrainCarriage = {\n  type: CarriageType;\n  color: string;\n  // Position tracking for smooth multi-carriage movement\n  tileX: number;\n  tileY: number;\n  progress: number;\n  direction: CarDirection;\n};\n\n/** Complete train with multiple carriages */\nexport type Train = {\n  id: number;\n  type: TrainType;\n  carriages: TrainCarriage[];\n  // Lead locomotive position\n  tileX: number;\n  tileY: number;\n  direction: CarDirection;\n  progress: number;\n  speed: number;\n  // Path for the train\n  path: { x: number; y: number }[];\n  pathIndex: number;\n  // Lifecycle\n  age: number;\n  maxAge: number;\n  // Visual\n  color: string;\n  // Station stops\n  atStation: boolean;\n  stationWaitTimer: number;\n  // Smoke particles for freight locomotives\n  smokeParticles: TrainSmokeParticle[];\n  smokeSpawnTimer: number;\n};\n"],"names":[],"mappings":"AAAA,kDAAkD;;;;;;;;;;;AAK3C,MAAM,aAAa;AACnB,MAAM,eAAe;AACrB,MAAM,cAAc,aAAa;AACjC,MAAM,gBAAgB"}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethanchen/Projects/hackajohn/packages/isometric-city/src/components/game/constants.ts"],"sourcesContent":["import { BuildingType } from '@/games/isocity/types';\nimport { DirectionMeta } from '@/core/types';\nimport { CarDirection, TILE_WIDTH, TILE_HEIGHT } from './types';\n\n// Vehicle colors (duller/muted versions)\nexport const CAR_COLORS = ['#d97777', '#d4a01f', '#2ba67a', '#4d84c8', '#9a6ac9'];\nexport const BUS_COLORS = ['#f59e0b', '#ef4444', '#3b82f6', '#10b981', '#9333ea'];\n\n// Bus system constants\nexport const BUS_MIN_POPULATION = 600; // Minimum population required for buses\nexport const BUS_MIN_ZOOM = 0.35; // Minimum zoom to show buses\nexport const BUS_SPEED_MIN = 0.3;\nexport const BUS_SPEED_MAX = 0.45;\nexport const MAX_BUSES = 35;\nexport const MAX_BUSES_MOBILE = 8;\nexport const BUS_SPAWN_INTERVAL_MIN = 2.5;\nexport const BUS_SPAWN_INTERVAL_MAX = 6.0;\nexport const BUS_STOP_DURATION_MIN = 1.6;\nexport const BUS_STOP_DURATION_MAX = 3.5;\n\n// Pedestrian appearance colors - includes lighter skin tones\nexport const PEDESTRIAN_SKIN_COLORS = ['#ffe4c4', '#ffd5b8', '#ffc8a8', '#fdbf7e', '#e0ac69', '#c68642', '#8d5524', '#613318'];\nexport const PEDESTRIAN_SHIRT_COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#8b5cf6', '#ec4899', '#ffffff', '#1f2937'];\nexport const PEDESTRIAN_PANTS_COLORS = ['#1f2937', '#374151', '#4b5563', '#1e3a8a', '#7c2d12', '#365314'];\nexport const PEDESTRIAN_HAT_COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#f97316', '#8b5cf6', '#1f2937', '#ffffff'];\n\n// Pedestrian behavior constants\nexport const PEDESTRIAN_BUILDING_ENTER_TIME = 2.0;  // Time to enter/exit building (seconds) - slow enough to see\nexport const PEDESTRIAN_APPROACH_TIME = 3.0;        // Time spent walking from road to shop entrance\nexport const PEDESTRIAN_MIN_ACTIVITY_TIME = 20.0;   // Minimum time at an activity\nexport const PEDESTRIAN_MAX_ACTIVITY_TIME = 120.0;  // Maximum time at an activity\nexport const PEDESTRIAN_BUILDING_MIN_TIME = 15.0;   // Minimum time inside buildings (reduced for more flow)\nexport const PEDESTRIAN_BUILDING_MAX_TIME = 60.0;   // Maximum time inside buildings (reduced for more flow)\nexport const PEDESTRIAN_SOCIAL_CHANCE = 0.02;       // Chance to stop and socialize (reduced for perf)\nexport const PEDESTRIAN_SOCIAL_DURATION = 4.0;      // How long socializing lasts\nexport const PEDESTRIAN_DOG_CHANCE = 0.05;          // Chance of walking a dog (reduced for perf)\nexport const PEDESTRIAN_BAG_CHANCE = 0.15;          // Chance of carrying a bag\nexport const PEDESTRIAN_HAT_CHANCE = 0.15;          // Chance of wearing a hat\nexport const PEDESTRIAN_IDLE_CHANCE = 0.01;         // Chance to stop and idle briefly (reduced for perf)\n\n// Beach/swimming pedestrian constants\nexport const PEDESTRIAN_BEACH_CHANCE = 0.15;        // Chance a park-bound pedestrian goes to beach instead\nexport const PEDESTRIAN_BEACH_MIN_TIME = 30.0;      // Minimum time at beach\nexport const PEDESTRIAN_BEACH_MAX_TIME = 180.0;     // Maximum time at beach\nexport const PEDESTRIAN_BEACH_SWIM_CHANCE = 0.6;    // Chance of swimming vs lying on mat\nexport const PEDESTRIAN_MAT_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f1c40f', '#9b59b6', '#e67e22', '#1abc9c', '#ff69b4'];\nexport const MAX_BEACH_SWIMMERS_PER_TILE = 3;       // Max swimmers per water tile\nexport const MAX_BEACH_MATS_PER_EDGE = 2;           // Max mats per beach edge\n\n// Pedestrian performance limits\nexport const PEDESTRIAN_MAX_COUNT = 560;            // Maximum pedestrians (hard cap) - reduced ~30%\nexport const PEDESTRIAN_MAX_COUNT_MOBILE = 80;      // Mobile: much lower for performance\nexport const PEDESTRIAN_ROAD_TILE_DENSITY = 1.7;    // Target pedestrians per road tile - reduced ~30%\nexport const PEDESTRIAN_ROAD_TILE_DENSITY_MOBILE = 0.5; // Mobile: lower density\nexport const PEDESTRIAN_SPAWN_BATCH_SIZE = 25;      // How many to try spawning at once\nexport const PEDESTRIAN_SPAWN_BATCH_SIZE_MOBILE = 5; // Mobile: smaller batches\nexport const PEDESTRIAN_SPAWN_INTERVAL = 0.03;      // Seconds between spawn batches\nexport const PEDESTRIAN_SPAWN_INTERVAL_MOBILE = 0.15; // Mobile: slower spawning\nexport const PEDESTRIAN_UPDATE_SKIP_DISTANCE = 30;  // Skip detailed updates for pedestrians this far from view\n\n// Zoom limits for camera\nexport const ZOOM_MIN = 0.3;                      // Minimum zoom level (most zoomed out - for large maps/multiple cities)\nexport const ZOOM_MAX = 5;                       // Maximum zoom level (most zoomed in)\n\n// Zoom thresholds for rendering detail elements\n// Lower values = more zoomed out, higher values = more zoomed in required\nexport const CAR_MIN_ZOOM = 0.4;                  // Desktop car threshold (cars hidden when very zoomed out)\nexport const CAR_MIN_ZOOM_MOBILE = 0.45;          // Mobile car threshold (slightly higher for perf)\nexport const PEDESTRIAN_MIN_ZOOM = 0.5;           // Desktop pedestrian threshold\nexport const PEDESTRIAN_MIN_ZOOM_MOBILE = 0.55;   // Mobile pedestrian threshold (slightly higher for perf)\n\n// Vehicle rendering thresholds - hide at very zoomed out levels for performance\nexport const VEHICLE_FAR_ZOOM_THRESHOLD = 0.25;   // Below this zoom: hide ALL vehicles/pedestrians on desktop too\nexport const TRAIN_MIN_ZOOM_FAR = 0.20;           // Trains visible slightly further out than cars\nexport const BOAT_MIN_ZOOM_FAR = 0.20;            // Boats visible at moderate zoom\nexport const HELICOPTER_MIN_ZOOM_FAR = 0.20;      // Helicopters visible at moderate zoom\nexport const AIRPLANE_MIN_ZOOM_FAR = 0;           // Airplanes always visible at all zoom levels\nexport const TRAFFIC_LIGHT_MIN_ZOOM = 0.45;       // Traffic lights at intersections\nexport const DIRECTION_ARROWS_MIN_ZOOM = 0.65;    // Directional arrows on merged roads\nexport const MEDIAN_PLANTS_MIN_ZOOM = 0.55;       // Plants/shrubs on road medians\nexport const LANE_MARKINGS_MIN_ZOOM = 0.5;        // Lane markings and road lines\nexport const LANE_MARKINGS_MEDIAN_MIN_ZOOM = 0.6; // Median markings for avenues/highways\nexport const SIDEWALK_MIN_ZOOM = 0.25;            // Sidewalks on road edges (desktop)\nexport const SIDEWALK_MIN_ZOOM_MOBILE = 0.25;     // Sidewalks on mobile (lower = visible when more zoomed out)\nexport const SKIP_SMALL_ELEMENTS_ZOOM_THRESHOLD = 0.5; // Desktop: hide boats/helis/smog during pan/zoom when below this\n\n// Airplane system constants\nexport const AIRPLANE_MIN_POPULATION = 2000; // Minimum population required for airplane activity\nexport const AIRPLANE_COLORS = ['#ffffff', '#1e40af', '#dc2626', '#059669', '#7c3aed']; // Airline liveries (fallback)\nexport const CONTRAIL_MAX_AGE = 3.0; // seconds\nexport const CONTRAIL_SPAWN_INTERVAL = 0.02; // seconds between contrail particles\n\n// Airplane sprite sheet configuration\nexport const AIRPLANE_SPRITE_SRC = '/assets/sprites_red_water_new_planes.png';\nexport const AIRPLANE_SPRITE_COLS = 5; // 5 columns per row\nexport const AIRPLANE_SPRITE_ROWS = 6; // 6 rows total\n// Plane types by row (0-indexed): 737, 777, 747, a380, seaplane, g650\nexport const PLANE_TYPE_ROWS: Record<string, number> = {\n  '737': 0,\n  '777': 1,\n  '747': 2,\n  'a380': 3,\n  'seaplane': 4, // Row 4 is the seaplane\n  'g650': 5,\n};\n// Available plane types (weighted toward smaller planes for variety)\nexport const PLANE_TYPES: Array<'737' | '777' | '747' | 'a380' | 'g650'> = ['737', '737', '737', '777', '777', '747', 'g650'];\n// Column mapping for each direction\n// Col 0: SW (South West), Col 1: NE (North East), Col 2: W (West), Col 3: N (North top-down), Col 4: unused\n// For opposite directions, mirror the sprite appropriately:\n// - W→E: horizontal flip (mirrorX)\n// - N→S: vertical flip (mirrorY)\n// - SE: use NE sprite (col 1) with vertical flip\n// - NW: use SW sprite (col 0) with vertical flip\n// baseAngle = the angle the sprite visually faces; rotationOffset = planeAngle - baseAngle\nexport const PLANE_DIRECTION_COLS: Record<string, { col: number; mirrorX: boolean; mirrorY: boolean; baseAngle: number }> = {\n  // Original sprites - baseAngle is what direction the sprite is drawn facing\n  'sw': { col: 0, mirrorX: false, mirrorY: false, baseAngle: (3 * Math.PI) / 4 + 0.26 },  // ~150° - South West (col 0)\n  'ne': { col: 1, mirrorX: false, mirrorY: false, baseAngle: -Math.PI / 4 + 0.17 },        // ~-35° - North East (col 1)\n  'w': { col: 2, mirrorX: false, mirrorY: false, baseAngle: Math.PI },                    // 180° - West (col 2)\n  'n': { col: 3, mirrorX: false, mirrorY: false, baseAngle: (3 * Math.PI) / 2 },          // 270° - North top-down (col 3)\n  // Derived directions through mirroring\n  'se': { col: 0, mirrorX: true, mirrorY: false, baseAngle: Math.PI / 4 - 0.26 },         // SW mirrored horizontally = SE\n  'nw': { col: 1, mirrorX: false, mirrorY: true, baseAngle: Math.PI / 4 - 0.26 },         // NE mirrored vertically then rotated = NW (~30°)\n  'e': { col: 2, mirrorX: true, mirrorY: false, baseAngle: 0 },                           // 0° - East (W mirrored horizontally)\n  's': { col: 3, mirrorX: false, mirrorY: true, baseAngle: Math.PI / 2 },                 // 90° - South (N mirrored vertically)\n};\n\n// Direction overrides for planes that cannot use col 1 (NE): seaplane and g650\n// Use col 3 (N) instead\nexport const COL1_OVERRIDE_PLANE_TYPES = ['seaplane', 'g650'];\nexport const COL1_DIRECTION_OVERRIDES: Record<string, { col: number; mirrorX: boolean; mirrorY: boolean; baseAngle: number }> = {\n  'ne': { col: 3, mirrorX: true, mirrorY: false, baseAngle: -Math.PI / 4 - 0.69 },        // Use N sprite rotated for NE\n  'se': { col: 3, mirrorX: true, mirrorY: true, baseAngle: (3 * Math.PI) / 4 - 0.78 },    // Use N sprite rotated for SE (30° clockwise)\n  'nw': { col: 3, mirrorX: false, mirrorY: false, baseAngle: (3 * Math.PI) / 2 },         // Use N sprite (facing 270°) without mirroring, rotation handles NW\n};\n// Plane scale factors by type (larger planes are bigger)\n// Scaled down 20% from previous values\nexport const PLANE_SCALES: Record<string, number> = {\n  '737': 0.152,\n  '777': 0.184,\n  '747': 0.196,\n  'a380': 0.224,\n  'g650': 0.112,\n  'seaplane': 0.09, // Scaled down 20% more (total ~45% from original)\n};\n\n// Seaplane system constants\nexport const SEAPLANE_MIN_POPULATION = 3000; // Minimum population for seaplanes\nexport const SEAPLANE_MIN_BAY_SIZE = 12; // Minimum water tiles for a bay to support seaplanes\nexport const SEAPLANE_COLORS = ['#ffffff', '#1e40af', '#dc2626', '#f97316', '#059669']; // Seaplane liveries\nexport const MAX_SEAPLANES = 25; // Maximum seaplanes in the city\nexport const MAX_SEAPLANES_MOBILE = 5; // Mobile: fewer seaplanes for performance\nexport const SEAPLANE_SPAWN_INTERVAL_MIN = 4; // Minimum seconds between spawns\nexport const SEAPLANE_SPAWN_INTERVAL_MAX = 10; // Maximum seconds between spawns\nexport const SEAPLANE_TAXI_TIME_MIN = 4; // Minimum seconds taxiing on water before takeoff\nexport const SEAPLANE_TAXI_TIME_MAX = 10; // Maximum seconds taxiing\nexport const SEAPLANE_DOCK_TIME_MIN = 8; // Minimum seconds docked at marina/pier\nexport const SEAPLANE_DOCK_TIME_MAX = 20; // Maximum seconds docked\nexport const SEAPLANE_FLIGHT_TIME_MIN = 25; // Minimum flight time in seconds\nexport const SEAPLANE_FLIGHT_TIME_MAX = 50; // Maximum flight time\nexport const SEAPLANE_WATER_SPEED = 18; // Speed when taxiing on water (px/sec)\nexport const SEAPLANE_DOCK_APPROACH_SPEED = 12; // Speed when approaching dock\nexport const SEAPLANE_TAKEOFF_SPEED = 60; // Speed during takeoff run\nexport const SEAPLANE_FLIGHT_SPEED_MIN = 70; // Minimum cruising speed\nexport const SEAPLANE_FLIGHT_SPEED_MAX = 100; // Maximum cruising speed\nexport const SEAPLANE_MIN_ZOOM = 0.3; // Minimum zoom to show seaplanes\nexport const SEAPLANE_MAX_FLIGHTS = 3; // Maximum flights before despawning\n\n// Helicopter system constants\nexport const HELICOPTER_MIN_POPULATION = 3000; // Minimum population required for helicopter activity\nexport const HELICOPTER_COLORS = ['#dc2626', '#ffffff', '#1e3a8a', '#f97316', '#059669']; // Red cross, white, navy, orange, green\nexport const ROTOR_WASH_MAX_AGE = 1.0; // seconds - shorter than plane contrails\nexport const ROTOR_WASH_SPAWN_INTERVAL = 0.04; // seconds between rotor wash particles\n\n// Water asset path\nexport const WATER_ASSET_PATH = '/assets/water.png';\n\n// Boat system constants\nexport const BOAT_COLORS = ['#ffffff', '#1e3a5f', '#8b4513', '#2f4f4f', '#c41e3a', '#1e90ff']; // Various boat hull colors\nexport const BOAT_MIN_ZOOM = 0.3; // Minimum zoom level to show boats\nexport const WAKE_MIN_ZOOM_MOBILE = 0.45; // Minimum zoom level to show wakes on mobile (matches traffic lights threshold)\nexport const BOATS_PER_DOCK = 1.5; // Number of boats per marina/pier\nexport const BOATS_PER_DOCK_MOBILE = 0.5; // Mobile: fewer boats per dock\nexport const MAX_BOATS = 12; // Maximum total boats in the city\nexport const MAX_BOATS_MOBILE = 4; // Mobile: fewer boats for performance\nexport const WAKE_MAX_AGE = 2.0; // seconds - how long wake particles last\nexport const WAKE_SPAWN_INTERVAL = 0.03; // seconds between wake particles\n\n// Barge system constants (ocean cargo ships)\nexport const BARGE_COLORS = ['#2c3e50', '#34495e', '#7f8c8d', '#c0392b', '#27ae60', '#2980b9']; // Industrial ship colors\nexport const BARGE_MIN_ZOOM = 0.25; // Minimum zoom level to show barges (slightly lower than boats)\nexport const BARGE_SPEED_MIN = 8; // Minimum speed (pixels/second) - slower than boats\nexport const BARGE_SPEED_MAX = 12; // Maximum speed (pixels/second)\nexport const MAX_BARGES = 4; // Maximum barges in the city at once\nexport const MAX_BARGES_MOBILE = 2; // Mobile: fewer barges for performance\nexport const BARGE_SPAWN_INTERVAL_MIN = 8; // Minimum seconds between barge spawns\nexport const BARGE_SPAWN_INTERVAL_MAX = 20; // Maximum seconds between barge spawns\nexport const BARGE_DOCK_TIME_MIN = 8; // Minimum seconds docked at marina\nexport const BARGE_DOCK_TIME_MAX = 15; // Maximum seconds docked at marina\nexport const BARGE_CARGO_VALUE_MIN = 100; // Minimum cargo value (adds to city income per delivery)\nexport const BARGE_CARGO_VALUE_MAX = 350; // Maximum cargo value (makes ocean marinas worthwhile)\nexport const BARGE_WAKE_SPAWN_INTERVAL = 0.05; // Slower wake spawn than boats (larger vessel)\n\n// Factory smog system constants\nexport const SMOG_BUILDINGS: BuildingType[] = ['factory_medium', 'factory_large'];\nexport const SMOG_PARTICLE_MAX_AGE = 8.0; // seconds - how long smog particles last\nexport const SMOG_PARTICLE_MAX_AGE_MOBILE = 5.0; // seconds - shorter on mobile for performance\nexport const SMOG_SPAWN_INTERVAL_MEDIUM = 0.4; // seconds between particles for medium factory\nexport const SMOG_SPAWN_INTERVAL_LARGE = 0.2; // seconds between particles for large factory\nexport const SMOG_SPAWN_INTERVAL_MOBILE_MULTIPLIER = 2.0; // Spawn less frequently on mobile\nexport const SMOG_DRIFT_SPEED = 8; // pixels per second horizontal drift\nexport const SMOG_RISE_SPEED = 12; // pixels per second upward drift\nexport const SMOG_MAX_ZOOM = 1.2; // Zoom level above which smog starts to fade\nexport const SMOG_FADE_ZOOM = 1.8; // Zoom level at which smog is fully invisible\nexport const SMOG_BASE_OPACITY = 0.25; // Base opacity of smog particles\nexport const SMOG_PARTICLE_SIZE_MIN = 8; // Minimum particle size\nexport const SMOG_PARTICLE_SIZE_MAX = 20; // Maximum particle size\nexport const SMOG_PARTICLE_GROWTH = 0.5; // How much particles grow per second\nexport const SMOG_MAX_PARTICLES_PER_FACTORY = 25; // Maximum particles per factory to prevent memory issues\nexport const SMOG_MAX_PARTICLES_PER_FACTORY_MOBILE = 12; // Lower limit on mobile\n\n// Train smoke constants (freight locomotives only)\nexport const TRAIN_SMOKE_PARTICLE_MAX_AGE = 1.8; // seconds - short-lived compact puffs\nexport const TRAIN_SMOKE_SPAWN_INTERVAL = 0.15; // seconds between puffs\nexport const TRAIN_SMOKE_SPAWN_INTERVAL_MOBILE = 0.3; // Less frequent on mobile\nexport const TRAIN_SMOKE_DRIFT_SPEED = 8; // pixels per second horizontal drift (slower)\nexport const TRAIN_SMOKE_RISE_SPEED = 18; // pixels per second upward drift\nexport const TRAIN_SMOKE_BASE_OPACITY = 0.5; // Higher opacity for compact puffs\nexport const TRAIN_SMOKE_PARTICLE_SIZE_MIN = 2; // Tiny puffs\nexport const TRAIN_SMOKE_PARTICLE_SIZE_MAX = 4; // Small max size\nexport const TRAIN_SMOKE_PARTICLE_GROWTH = 0.8; // Slow growth - stays compact\nexport const TRAIN_SMOKE_MAX_PARTICLES = 12; // Max particles per train\nexport const TRAIN_SMOKE_MAX_PARTICLES_MOBILE = 6;\n\n// Firework system constants\nexport const FIREWORK_BUILDINGS: BuildingType[] = ['baseball_stadium', 'amusement_park', 'marina_docks_small', 'pier_large'];\nexport const FIREWORK_COLORS = [\n  '#ff4444', '#ff6b6b', // Reds\n  '#44ff44', '#6bff6b', // Greens\n  '#4444ff', '#6b6bff', // Blues\n  '#ffff44', '#ffff6b', // Yellows\n  '#ff44ff', '#ff6bff', // Magentas\n  '#44ffff', '#6bffff', // Cyans\n  '#ff8844', '#ffaa44', // Oranges\n  '#ffffff', '#ffffee', // Whites\n];\nexport const FIREWORK_PARTICLE_COUNT = 40; // Particles per explosion\nexport const FIREWORK_PARTICLE_SPEED = 120; // Initial particle velocity\nexport const FIREWORK_PARTICLE_MAX_AGE = 1.5; // seconds - how long particles last\nexport const FIREWORK_LAUNCH_SPEED = 180; // pixels per second upward\nexport const FIREWORK_SPAWN_INTERVAL_MIN = 0.3; // seconds between firework launches\nexport const FIREWORK_SPAWN_INTERVAL_MAX = 1.2; // seconds between firework launches\nexport const FIREWORK_SHOW_DURATION = 45; // seconds - how long a firework show lasts\nexport const FIREWORK_SHOW_CHANCE = 0.35; // 35% chance of fireworks on any given night\n\n// Direction metadata helpers\nfunction createDirectionMeta(step: { x: number; y: number }, vec: { dx: number; dy: number }): DirectionMeta {\n  const length = Math.hypot(vec.dx, vec.dy) || 1;\n  return {\n    step,\n    vec,\n    angle: Math.atan2(vec.dy, vec.dx),\n    normal: { nx: -vec.dy / length, ny: vec.dx / length },\n  };\n}\n\nexport const DIRECTION_META: Record<CarDirection, DirectionMeta> = {\n  north: createDirectionMeta({ x: -1, y: 0 }, { dx: -TILE_WIDTH / 2, dy: -TILE_HEIGHT / 2 }),\n  east: createDirectionMeta({ x: 0, y: -1 }, { dx: TILE_WIDTH / 2, dy: -TILE_HEIGHT / 2 }),\n  south: createDirectionMeta({ x: 1, y: 0 }, { dx: TILE_WIDTH / 2, dy: TILE_HEIGHT / 2 }),\n  west: createDirectionMeta({ x: 0, y: 1 }, { dx: -TILE_WIDTH / 2, dy: TILE_HEIGHT / 2 }),\n};\n\nexport const OPPOSITE_DIRECTION: Record<CarDirection, CarDirection> = {\n  north: 'south',\n  east: 'west',\n  south: 'north',\n  west: 'east',\n};\n\n// Traffic light timing constants (faster cycle)\nexport const TRAFFIC_LIGHT_GREEN_DURATION = 3.0;   // Seconds\nexport const TRAFFIC_LIGHT_YELLOW_DURATION = 0.8;  // Seconds\nexport const TRAFFIC_LIGHT_CYCLE = 7.6;            // Full cycle time\n\n// Train system constants\nexport const TRAIN_MIN_ZOOM = 0.35;               // Minimum zoom to show trains (normal)\nexport const TRAIN_SPAWN_INTERVAL = 3.0;          // Seconds between train spawn attempts\nexport const TRAIN_SPAWN_INTERVAL_MOBILE = 6.0;   // Mobile: slower train spawning\nexport const MIN_RAIL_TILES_FOR_TRAINS = 10;      // Minimum rail tiles needed\nexport const MAX_TRAINS = 35;                      // Maximum trains in city\nexport const MAX_TRAINS_MOBILE = 8;               // Mobile: fewer trains for performance\n\n// Far zoom thresholds - all mobile/animated entities hidden below these levels\nexport const HELICOPTER_MIN_ZOOM = 0.3;           // Minimum zoom to show helicopters\nexport const SMOG_MIN_ZOOM = 0.35;                // Minimum zoom to show factory smog\nexport const FIREWORK_MIN_ZOOM = 0.3;             // Minimum zoom to show fireworks\n\n// PERF: Pre-computed building type sets for O(1) lookups during lighting calculations\n// These are module-level constants to avoid allocating on every render frame\nexport const NON_LIT_BUILDING_TYPES = new Set(['grass', 'empty', 'water', 'road', 'tree', 'park', 'park_large', 'tennis']);\nexport const RESIDENTIAL_BUILDING_TYPES = new Set(['house_small', 'house_medium', 'mansion', 'apartment_low', 'apartment_high']);\nexport const COMMERCIAL_BUILDING_TYPES = new Set(['shop_small', 'shop_medium', 'office_low', 'office_high', 'mall']);\n\n// Cloud system constants\nexport const CLOUD_MIN_ZOOM = 0.2;                    // Minimum zoom to show clouds (always visible when not super zoomed out)\nexport const CLOUD_MAX_ZOOM = 1.0;                    // Zoom level above which clouds start to fade when zoomed in (focus on city)\nexport const CLOUD_FADE_ZOOM = 1.6;                   // Zoom level at which clouds are fully invisible when zoomed in\nexport const CLOUD_MAX_COVERAGE = 0.35;               // Viewport fraction (0–1) above which clouds start to fade (e.g. 35% covered)\nexport const CLOUD_COVERAGE_FADE_END = 0.7;           // At this coverage fraction, clouds are fully faded (e.g. 70% covered)\nexport const CLOUD_MAX_COUNT = 18;                    // Maximum clouds on screen (increased for diversity)\nexport const CLOUD_MAX_COUNT_MOBILE = 10;             // Fewer clouds on mobile for performance\nexport const CLOUD_SPAWN_INTERVAL = 2.5;              // Seconds between cloud spawn attempts\nexport const CLOUD_SPAWN_INTERVAL_MOBILE = 4.5;       // Slower spawning on mobile\nexport const CLOUD_SPEED_MIN = 8;                     // Minimum cloud drift speed (pixels/second)\nexport const CLOUD_SPEED_MAX = 24;                    // Maximum cloud drift speed (cirrus moves faster)\nexport const CLOUD_SCALE_MIN = 0.5;                   // Minimum cloud scale\nexport const CLOUD_SCALE_MAX = 1.8;                   // Maximum cloud scale\nexport const CLOUD_PUFF_COUNT_MIN = 4;                // Minimum puffs per cloud (cumulus)\nexport const CLOUD_PUFF_COUNT_MAX = 10;               // Maximum puffs per cloud\nexport const CLOUD_PUFF_SIZE_MIN = 20;                // Minimum puff radius\nexport const CLOUD_PUFF_SIZE_MAX = 55;                // Maximum puff radius\nexport const CLOUD_WIDTH = 150;                       // Approximate cloud width for spawn offset\nexport const CLOUD_DESPAWN_MARGIN = 300;              // Distance past viewport to despawn clouds\n// Wind direction: clouds drift from southwest to northeast (isometric perspective)\nexport const CLOUD_WIND_ANGLE = -Math.PI / 4;         // ~-45 degrees (southwest to northeast)\n// Parallax effect: higher clouds move faster\nexport const CLOUD_LAYER_SPEEDS = [0.7, 1.0, 1.4];    // Speed multipliers for low/mid/high layers\nexport const CLOUD_LAYER_OPACITY = [0.85, 1.0, 0.9];  // Opacity multipliers for layers\n// Night darkening - clouds get slightly darker at night\nexport const CLOUD_NIGHT_OPACITY_MULT = 0.6;          // Clouds are less visible at night\n\n// =============================================================================\n// CLOUD TYPE CONFIGURATION - climate diversity and meteorological variety\n// =============================================================================\n// Spawn weights by time of day (hour 0-23): [cumulus, stratus, cirrus, cumulonimbus, altocumulus]\n// Morning (6-9): More stratus/fog lifting, some altocumulus\n// Midday (10-16): Cumulus dominant (fair weather), occasional cumulonimbus (afternoon storms)\n// Evening (17-20): More altocumulus, stratus building, dramatic cumulonimbus at sunset\n// Night (21-5): Cirrus and stratus more common (harder to see but add atmosphere)\nexport const CLOUD_TYPE_WEIGHTS_BY_HOUR: Record<number, [number, number, number, number, number]> = {\n  0: [2, 4, 5, 0, 3],  1: [2, 4, 5, 0, 3],  2: [2, 4, 5, 0, 3],  3: [2, 4, 5, 0, 3],\n  4: [2, 4, 5, 0, 3],  5: [3, 5, 4, 0, 4],  // Pre-dawn: stratus, cirrus\n  6: [4, 6, 3, 0, 5],  7: [5, 5, 3, 0, 5],  8: [6, 4, 3, 0, 5],  9: [7, 3, 3, 0, 4],  // Morning: stratus burns off, cumulus builds\n  10: [8, 2, 4, 1, 4], 11: [9, 2, 4, 1, 3], 12: [9, 2, 4, 2, 3], 13: [8, 2, 4, 3, 3],  // Midday: cumulus dominant, afternoon storm chance\n  14: [8, 2, 4, 3, 3], 15: [7, 2, 4, 3, 4], 16: [6, 3, 4, 2, 4],  // Late afternoon: cumulonimbus\n  17: [5, 4, 4, 2, 5], 18: [4, 5, 4, 1, 6], 19: [3, 5, 5, 1, 5],  // Evening: altocumulus, stratus\n  20: [2, 5, 5, 0, 4], 21: [2, 4, 5, 0, 3], 22: [2, 4, 5, 0, 3], 23: [2, 4, 5, 0, 3],  // Night: cirrus, stratus\n};\n\n// Fallback weights when hour not in map\nexport const CLOUD_TYPE_WEIGHTS_DEFAULT: [number, number, number, number, number] = [6, 3, 4, 1, 4];\n\n// Cloud types in order for the weights array\nexport const CLOUD_TYPES_ORDERED = ['cumulus', 'stratus', 'cirrus', 'cumulonimbus', 'altocumulus'] as const;\n\n// Per-type visual configuration: opacity range, layer restrictions, speed modifier, scale range\n// layer 0=low only, 1=mid only, 2=high only, or -1=any\nexport const CLOUD_TYPE_CONFIG: Record<string, {\n  opacityMin: number; opacityMax: number;\n  layerRestriction: number;  // -1 = any layer, 0/1/2 = only that layer\n  speedMult: number;        // 0.8 = slower, 1.2 = faster (cirrus moves fast)\n  scaleMin: number; scaleMax: number;\n  puffCountMin: number; puffCountMax: number;\n  // Puff shape: stretchX, stretchY (1=round, >1=elongated in that axis)\n  puffStretchX: [number, number]; puffStretchY: [number, number];\n}> = {\n  cumulus:    { opacityMin: 0.2,  opacityMax: 0.4,  layerRestriction: -1, speedMult: 1.0,  scaleMin: 0.7, scaleMax: 1.5, puffCountMin: 5, puffCountMax: 9,  puffStretchX: [1, 1],   puffStretchY: [1, 1] },\n  stratus:    { opacityMin: 0.25, opacityMax: 0.45, layerRestriction: 0,  speedMult: 0.85, scaleMin: 1.0, scaleMax: 1.6, puffCountMin: 8, puffCountMax: 14, puffStretchX: [2, 3],   puffStretchY: [0.4, 0.6] },  // Flat, wide, layered\n  cirrus:     { opacityMin: 0.06, opacityMax: 0.18, layerRestriction: 2,  speedMult: 1.5,  scaleMin: 0.8, scaleMax: 1.4, puffCountMin: 2, puffCountMax: 5,  puffStretchX: [2, 4],   puffStretchY: [0.3, 0.5] },  // Wispy, high, faint\n  cumulonimbus: { opacityMin: 0.3, opacityMax: 0.5, layerRestriction: 0,  speedMult: 0.7,  scaleMin: 1.2, scaleMax: 1.9, puffCountMin: 6, puffCountMax: 10, puffStretchX: [1, 1.2], puffStretchY: [1, 1.3] },  // Towering, low, dramatic\n  altocumulus: { opacityMin: 0.15, opacityMax: 0.35, layerRestriction: 1,  speedMult: 1.1,  scaleMin: 0.6, scaleMax: 1.2, puffCountMin: 4, puffCountMax: 8,  puffStretchX: [1, 1.5], puffStretchY: [0.7, 1] },  // Patchy, mid-level\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;AAGO,MAAM,aAAa;IAAC;IAAW;IAAW;IAAW;IAAW;CAAU;AAC1E,MAAM,aAAa;IAAC;IAAW;IAAW;IAAW;IAAW;CAAU;AAG1E,MAAM,qBAAqB,KAAK,wCAAwC;AACxE,MAAM,eAAe,MAAM,6BAA6B;AACxD,MAAM,gBAAgB;AACtB,MAAM,gBAAgB;AACtB,MAAM,YAAY;AAClB,MAAM,mBAAmB;AACzB,MAAM,yBAAyB;AAC/B,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB;AAC9B,MAAM,wBAAwB;AAG9B,MAAM,yBAAyB;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU;AACvH,MAAM,0BAA0B;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU;AACnI,MAAM,0BAA0B;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU;AAClG,MAAM,wBAAwB;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU;AAG3G,MAAM,iCAAiC,KAAM,6DAA6D;AAC1G,MAAM,2BAA2B,KAAY,gDAAgD;AAC7F,MAAM,+BAA+B,MAAQ,8BAA8B;AAC3E,MAAM,+BAA+B,OAAQ,8BAA8B;AAC3E,MAAM,+BAA+B,MAAQ,wDAAwD;AACrG,MAAM,+BAA+B,MAAQ,wDAAwD;AACrG,MAAM,2BAA2B,MAAY,kDAAkD;AAC/F,MAAM,6BAA6B,KAAU,6BAA6B;AAC1E,MAAM,wBAAwB,MAAe,6CAA6C;AAC1F,MAAM,wBAAwB,MAAe,2BAA2B;AACxE,MAAM,wBAAwB,MAAe,0BAA0B;AACvE,MAAM,yBAAyB,MAAc,qDAAqD;AAGlG,MAAM,0BAA0B,MAAa,uDAAuD;AACpG,MAAM,4BAA4B,MAAW,wBAAwB;AACrE,MAAM,4BAA4B,OAAW,wBAAwB;AACrE,MAAM,+BAA+B,KAAQ,qCAAqC;AAClF,MAAM,wBAAwB;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU;AACtH,MAAM,8BAA8B,GAAS,8BAA8B;AAC3E,MAAM,0BAA0B,GAAa,0BAA0B;AAGvE,MAAM,uBAAuB,KAAgB,gDAAgD;AAC7F,MAAM,8BAA8B,IAAS,qCAAqC;AAClF,MAAM,+BAA+B,KAAQ,kDAAkD;AAC/F,MAAM,sCAAsC,KAAK,wBAAwB;AACzE,MAAM,8BAA8B,IAAS,mCAAmC;AAChF,MAAM,qCAAqC,GAAG,0BAA0B;AACxE,MAAM,4BAA4B,MAAW,gCAAgC;AAC7E,MAAM,mCAAmC,MAAM,0BAA0B;AACzE,MAAM,kCAAkC,IAAK,2DAA2D;AAGxG,MAAM,WAAW,KAA0B,wEAAwE;AACnH,MAAM,WAAW,GAAyB,sCAAsC;AAIhF,MAAM,eAAe,KAAsB,2DAA2D;AACtG,MAAM,sBAAsB,MAAe,kDAAkD;AAC7F,MAAM,sBAAsB,KAAe,+BAA+B;AAC1E,MAAM,6BAA6B,MAAQ,yDAAyD;AAGpG,MAAM,6BAA6B,MAAQ,gEAAgE;AAC3G,MAAM,qBAAqB,MAAgB,gDAAgD;AAC3F,MAAM,oBAAoB,MAAiB,iCAAiC;AAC5E,MAAM,0BAA0B,MAAW,uCAAuC;AAClF,MAAM,wBAAwB,GAAa,8CAA8C;AACzF,MAAM,yBAAyB,MAAY,kCAAkC;AAC7E,MAAM,4BAA4B,MAAS,qCAAqC;AAChF,MAAM,yBAAyB,MAAY,gCAAgC;AAC3E,MAAM,yBAAyB,KAAY,+BAA+B;AAC1E,MAAM,gCAAgC,KAAK,uCAAuC;AAClF,MAAM,oBAAoB,MAAiB,oCAAoC;AAC/E,MAAM,2BAA2B,MAAU,6DAA6D;AACxG,MAAM,qCAAqC,KAAK,iEAAiE;AAGjH,MAAM,0BAA0B,MAAM,oDAAoD;AAC1F,MAAM,kBAAkB;IAAC;IAAW;IAAW;IAAW;IAAW;CAAU,EAAE,8BAA8B;AAC/G,MAAM,mBAAmB,KAAK,UAAU;AACxC,MAAM,0BAA0B,MAAM,qCAAqC;AAG3E,MAAM,sBAAsB;AAC5B,MAAM,uBAAuB,GAAG,oBAAoB;AACpD,MAAM,uBAAuB,GAAG,eAAe;AAE/C,MAAM,kBAA0C;IACrD,OAAO;IACP,OAAO;IACP,OAAO;IACP,QAAQ;IACR,YAAY;IACZ,QAAQ;AACV;AAEO,MAAM,cAA8D;IAAC;IAAO;IAAO;IAAO;IAAO;IAAO;IAAO;CAAO;AAStH,MAAM,uBAA+G;IAC1H,4EAA4E;IAC5E,MAAM;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAO,WAAW,AAAC,IAAI,KAAK,EAAE,GAAI,IAAI;IAAK;IACpF,MAAM;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAO,WAAW,CAAC,KAAK,EAAE,GAAG,IAAI;IAAK;IAC/E,KAAK;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAO,WAAW,KAAK,EAAE;IAAC;IAClE,KAAK;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAO,WAAW,AAAC,IAAI,KAAK,EAAE,GAAI;IAAE;IAC5E,uCAAuC;IACvC,MAAM;QAAE,KAAK;QAAG,SAAS;QAAM,SAAS;QAAO,WAAW,KAAK,EAAE,GAAG,IAAI;IAAK;IAC7E,MAAM;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAM,WAAW,KAAK,EAAE,GAAG,IAAI;IAAK;IAC7E,KAAK;QAAE,KAAK;QAAG,SAAS;QAAM,SAAS;QAAO,WAAW;IAAE;IAC3D,KAAK;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAM,WAAW,KAAK,EAAE,GAAG;IAAE;AACvE;AAIO,MAAM,4BAA4B;IAAC;IAAY;CAAO;AACtD,MAAM,2BAAmH;IAC9H,MAAM;QAAE,KAAK;QAAG,SAAS;QAAM,SAAS;QAAO,WAAW,CAAC,KAAK,EAAE,GAAG,IAAI;IAAK;IAC9E,MAAM;QAAE,KAAK;QAAG,SAAS;QAAM,SAAS;QAAM,WAAW,AAAC,IAAI,KAAK,EAAE,GAAI,IAAI;IAAK;IAClF,MAAM;QAAE,KAAK;QAAG,SAAS;QAAO,SAAS;QAAO,WAAW,AAAC,IAAI,KAAK,EAAE,GAAI;IAAE;AAC/E;AAGO,MAAM,eAAuC;IAClD,OAAO;IACP,OAAO;IACP,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,YAAY;AACd;AAGO,MAAM,0BAA0B,MAAM,mCAAmC;AACzE,MAAM,wBAAwB,IAAI,qDAAqD;AACvF,MAAM,kBAAkB;IAAC;IAAW;IAAW;IAAW;IAAW;CAAU,EAAE,oBAAoB;AACrG,MAAM,gBAAgB,IAAI,gCAAgC;AAC1D,MAAM,uBAAuB,GAAG,0CAA0C;AAC1E,MAAM,8BAA8B,GAAG,iCAAiC;AACxE,MAAM,8BAA8B,IAAI,iCAAiC;AACzE,MAAM,yBAAyB,GAAG,kDAAkD;AACpF,MAAM,yBAAyB,IAAI,0BAA0B;AAC7D,MAAM,yBAAyB,GAAG,wCAAwC;AAC1E,MAAM,yBAAyB,IAAI,yBAAyB;AAC5D,MAAM,2BAA2B,IAAI,iCAAiC;AACtE,MAAM,2BAA2B,IAAI,sBAAsB;AAC3D,MAAM,uBAAuB,IAAI,uCAAuC;AACxE,MAAM,+BAA+B,IAAI,8BAA8B;AACvE,MAAM,yBAAyB,IAAI,2BAA2B;AAC9D,MAAM,4BAA4B,IAAI,yBAAyB;AAC/D,MAAM,4BAA4B,KAAK,yBAAyB;AAChE,MAAM,oBAAoB,KAAK,iCAAiC;AAChE,MAAM,uBAAuB,GAAG,oCAAoC;AAGpE,MAAM,4BAA4B,MAAM,sDAAsD;AAC9F,MAAM,oBAAoB;IAAC;IAAW;IAAW;IAAW;IAAW;CAAU,EAAE,wCAAwC;AAC3H,MAAM,qBAAqB,KAAK,yCAAyC;AACzE,MAAM,4BAA4B,MAAM,uCAAuC;AAG/E,MAAM,mBAAmB;AAGzB,MAAM,cAAc;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU,EAAE,2BAA2B;AACnH,MAAM,gBAAgB,KAAK,mCAAmC;AAC9D,MAAM,uBAAuB,MAAM,gFAAgF;AACnH,MAAM,iBAAiB,KAAK,kCAAkC;AAC9D,MAAM,wBAAwB,KAAK,+BAA+B;AAClE,MAAM,YAAY,IAAI,kCAAkC;AACxD,MAAM,mBAAmB,GAAG,sCAAsC;AAClE,MAAM,eAAe,KAAK,yCAAyC;AACnE,MAAM,sBAAsB,MAAM,iCAAiC;AAGnE,MAAM,eAAe;IAAC;IAAW;IAAW;IAAW;IAAW;IAAW;CAAU,EAAE,yBAAyB;AAClH,MAAM,iBAAiB,MAAM,gEAAgE;AAC7F,MAAM,kBAAkB,GAAG,oDAAoD;AAC/E,MAAM,kBAAkB,IAAI,gCAAgC;AAC5D,MAAM,aAAa,GAAG,qCAAqC;AAC3D,MAAM,oBAAoB,GAAG,uCAAuC;AACpE,MAAM,2BAA2B,GAAG,uCAAuC;AAC3E,MAAM,2BAA2B,IAAI,uCAAuC;AAC5E,MAAM,sBAAsB,GAAG,mCAAmC;AAClE,MAAM,sBAAsB,IAAI,mCAAmC;AACnE,MAAM,wBAAwB,KAAK,yDAAyD;AAC5F,MAAM,wBAAwB,KAAK,uDAAuD;AAC1F,MAAM,4BAA4B,MAAM,+CAA+C;AAGvF,MAAM,iBAAiC;IAAC;IAAkB;CAAgB;AAC1E,MAAM,wBAAwB,KAAK,yCAAyC;AAC5E,MAAM,+BAA+B,KAAK,8CAA8C;AACxF,MAAM,6BAA6B,KAAK,+CAA+C;AACvF,MAAM,4BAA4B,KAAK,8CAA8C;AACrF,MAAM,wCAAwC,KAAK,kCAAkC;AACrF,MAAM,mBAAmB,GAAG,qCAAqC;AACjE,MAAM,kBAAkB,IAAI,iCAAiC;AAC7D,MAAM,gBAAgB,KAAK,6CAA6C;AACxE,MAAM,iBAAiB,KAAK,8CAA8C;AAC1E,MAAM,oBAAoB,MAAM,iCAAiC;AACjE,MAAM,yBAAyB,GAAG,wBAAwB;AAC1D,MAAM,yBAAyB,IAAI,wBAAwB;AAC3D,MAAM,uBAAuB,KAAK,qCAAqC;AACvE,MAAM,iCAAiC,IAAI,yDAAyD;AACpG,MAAM,wCAAwC,IAAI,wBAAwB;AAG1E,MAAM,+BAA+B,KAAK,sCAAsC;AAChF,MAAM,6BAA6B,MAAM,wBAAwB;AACjE,MAAM,oCAAoC,KAAK,0BAA0B;AACzE,MAAM,0BAA0B,GAAG,8CAA8C;AACjF,MAAM,yBAAyB,IAAI,iCAAiC;AACpE,MAAM,2BAA2B,KAAK,mCAAmC;AACzE,MAAM,gCAAgC,GAAG,aAAa;AACtD,MAAM,gCAAgC,GAAG,iBAAiB;AAC1D,MAAM,8BAA8B,KAAK,8BAA8B;AACvE,MAAM,4BAA4B,IAAI,0BAA0B;AAChE,MAAM,mCAAmC;AAGzC,MAAM,qBAAqC;IAAC;IAAoB;IAAkB;IAAsB;CAAa;AACrH,MAAM,kBAAkB;IAC7B;IAAW;IACX;IAAW;IACX;IAAW;IACX;IAAW;IACX;IAAW;IACX;IAAW;IACX;IAAW;IACX;IAAW;CACZ;AACM,MAAM,0BAA0B,IAAI,0BAA0B;AAC9D,MAAM,0BAA0B,KAAK,4BAA4B;AACjE,MAAM,4BAA4B,KAAK,oCAAoC;AAC3E,MAAM,wBAAwB,KAAK,2BAA2B;AAC9D,MAAM,8BAA8B,KAAK,oCAAoC;AAC7E,MAAM,8BAA8B,KAAK,oCAAoC;AAC7E,MAAM,yBAAyB,IAAI,2CAA2C;AAC9E,MAAM,uBAAuB,MAAM,6CAA6C;AAEvF,6BAA6B;AAC7B,SAAS,oBAAoB,IAA8B,EAAE,GAA+B;IAC1F,MAAM,SAAS,KAAK,KAAK,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE,KAAK;IAC7C,OAAO;QACL;QACA;QACA,OAAO,KAAK,KAAK,CAAC,IAAI,EAAE,EAAE,IAAI,EAAE;QAChC,QAAQ;YAAE,IAAI,CAAC,IAAI,EAAE,GAAG;YAAQ,IAAI,IAAI,EAAE,GAAG;QAAO;IACtD;AACF;AAEO,MAAM,iBAAsD;IACjE,OAAO,oBAAoB;QAAE,GAAG,CAAC;QAAG,GAAG;IAAE,GAAG;QAAE,IAAI,CAAC,iLAAU,GAAG;QAAG,IAAI,CAAC,kLAAW,GAAG;IAAE;IACxF,MAAM,oBAAoB;QAAE,GAAG;QAAG,GAAG,CAAC;IAAE,GAAG;QAAE,IAAI,iLAAU,GAAG;QAAG,IAAI,CAAC,kLAAW,GAAG;IAAE;IACtF,OAAO,oBAAoB;QAAE,GAAG;QAAG,GAAG;IAAE,GAAG;QAAE,IAAI,iLAAU,GAAG;QAAG,IAAI,kLAAW,GAAG;IAAE;IACrF,MAAM,oBAAoB;QAAE,GAAG;QAAG,GAAG;IAAE,GAAG;QAAE,IAAI,CAAC,iLAAU,GAAG;QAAG,IAAI,kLAAW,GAAG;IAAE;AACvF;AAEO,MAAM,qBAAyD;IACpE,OAAO;IACP,MAAM;IACN,OAAO;IACP,MAAM;AACR;AAGO,MAAM,+BAA+B,KAAO,UAAU;AACtD,MAAM,gCAAgC,KAAM,UAAU;AACtD,MAAM,sBAAsB,KAAgB,kBAAkB;AAG9D,MAAM,iBAAiB,MAAoB,uCAAuC;AAClF,MAAM,uBAAuB,KAAc,uCAAuC;AAClF,MAAM,8BAA8B,KAAO,gCAAgC;AAC3E,MAAM,4BAA4B,IAAS,4BAA4B;AACvE,MAAM,aAAa,IAAyB,yBAAyB;AACrE,MAAM,oBAAoB,GAAiB,uCAAuC;AAGlF,MAAM,sBAAsB,KAAe,mCAAmC;AAC9E,MAAM,gBAAgB,MAAqB,oCAAoC;AAC/E,MAAM,oBAAoB,KAAiB,iCAAiC;AAI5E,MAAM,yBAAyB,IAAI,IAAI;IAAC;IAAS;IAAS;IAAS;IAAQ;IAAQ;IAAQ;IAAc;CAAS;AAClH,MAAM,6BAA6B,IAAI,IAAI;IAAC;IAAe;IAAgB;IAAW;IAAiB;CAAiB;AACxH,MAAM,4BAA4B,IAAI,IAAI;IAAC;IAAc;IAAe;IAAc;IAAe;CAAO;AAG5G,MAAM,iBAAiB,KAAwB,yEAAyE;AACxH,MAAM,iBAAiB,KAAwB,6EAA6E;AAC5H,MAAM,kBAAkB,KAAuB,gEAAgE;AAC/G,MAAM,qBAAqB,MAAoB,8EAA8E;AAC7H,MAAM,0BAA0B,KAAe,uEAAuE;AACtH,MAAM,kBAAkB,IAAuB,qDAAqD;AACpG,MAAM,yBAAyB,IAAgB,yCAAyC;AACxF,MAAM,uBAAuB,KAAkB,uCAAuC;AACtF,MAAM,8BAA8B,KAAW,4BAA4B;AAC3E,MAAM,kBAAkB,GAAuB,4CAA4C;AAC3F,MAAM,kBAAkB,IAAuB,kDAAkD;AACjG,MAAM,kBAAkB,KAAuB,sBAAsB;AACrE,MAAM,kBAAkB,KAAuB,sBAAsB;AACrE,MAAM,uBAAuB,GAAkB,oCAAoC;AACnF,MAAM,uBAAuB,IAAkB,0BAA0B;AACzE,MAAM,sBAAsB,IAAmB,sBAAsB;AACrE,MAAM,sBAAsB,IAAmB,sBAAsB;AACrE,MAAM,cAAc,KAA2B,2CAA2C;AAC1F,MAAM,uBAAuB,KAAkB,2CAA2C;AAE1F,MAAM,mBAAmB,CAAC,KAAK,EAAE,GAAG,GAAW,wCAAwC;AAEvF,MAAM,qBAAqB;IAAC;IAAK;IAAK;CAAI,EAAK,4CAA4C;AAC3F,MAAM,sBAAsB;IAAC;IAAM;IAAK;CAAI,EAAG,iCAAiC;AAEhF,MAAM,2BAA2B,KAAc,mCAAmC;AAUlF,MAAM,6BAAuF;IAClG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IACjF,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IACvC,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAG,GAAG;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IACjF,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAClF,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAC7D,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAC7D,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;IAAE,IAAI;QAAC;QAAG;QAAG;QAAG;QAAG;KAAE;AACpF;AAGO,MAAM,6BAAuE;IAAC;IAAG;IAAG;IAAG;IAAG;CAAE;AAG5F,MAAM,sBAAsB;IAAC;IAAW;IAAW;IAAU;IAAgB;CAAc;AAI3F,MAAM,oBAQR;IACH,SAAY;QAAE,YAAY;QAAM,YAAY;QAAM,kBAAkB,CAAC;QAAG,WAAW;QAAM,UAAU;QAAK,UAAU;QAAK,cAAc;QAAG,cAAc;QAAI,cAAc;YAAC;YAAG;SAAE;QAAI,cAAc;YAAC;YAAG;SAAE;IAAC;IACvM,SAAY;QAAE,YAAY;QAAM,YAAY;QAAM,kBAAkB;QAAI,WAAW;QAAM,UAAU;QAAK,UAAU;QAAK,cAAc;QAAG,cAAc;QAAI,cAAc;YAAC;YAAG;SAAE;QAAI,cAAc;YAAC;YAAK;SAAI;IAAC;IAC3M,QAAY;QAAE,YAAY;QAAM,YAAY;QAAM,kBAAkB;QAAI,WAAW;QAAM,UAAU;QAAK,UAAU;QAAK,cAAc;QAAG,cAAc;QAAI,cAAc;YAAC;YAAG;SAAE;QAAI,cAAc;YAAC;YAAK;SAAI;IAAC;IAC3M,cAAc;QAAE,YAAY;QAAK,YAAY;QAAK,kBAAkB;QAAI,WAAW;QAAM,UAAU;QAAK,UAAU;QAAK,cAAc;QAAG,cAAc;QAAI,cAAc;YAAC;YAAG;SAAI;QAAE,cAAc;YAAC;YAAG;SAAI;IAAC;IACzM,aAAa;QAAE,YAAY;QAAM,YAAY;QAAM,kBAAkB;QAAI,WAAW;QAAM,UAAU;QAAK,UAAU;QAAK,cAAc;QAAG,cAAc;QAAI,cAAc;YAAC;YAAG;SAAI;QAAE,cAAc;YAAC;YAAK;SAAE;IAAC;AAC5M"}},
    {"offset": {"line": 1204, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethanchen/Projects/hackajohn/packages/isometric-city/src/components/game/utils.ts"],"sourcesContent":["import { Tile } from '@/types/game';\nimport { CarDirection, TILE_WIDTH, TILE_HEIGHT } from './types';\nimport { OPPOSITE_DIRECTION } from './constants';\n\n// PERF: Pre-allocated typed arrays for BFS pathfinding to reduce GC pressure\n// Max path length of 2048 nodes should be sufficient for most city sizes\nconst MAX_PATH_LENGTH = 2048;\nconst BFS_QUEUE_X = new Int16Array(MAX_PATH_LENGTH);\nconst BFS_QUEUE_Y = new Int16Array(MAX_PATH_LENGTH);\nconst BFS_PARENT_X = new Int16Array(MAX_PATH_LENGTH); // Parent index for path reconstruction\nconst BFS_PARENT_Y = new Int16Array(MAX_PATH_LENGTH);\nconst BFS_VISITED = new Uint8Array(256 * 256); // Max 256x256 grid size\n\n// Get opposite direction\nexport function getOppositeDirection(direction: CarDirection): CarDirection {\n  return OPPOSITE_DIRECTION[direction];\n}\n\n// Check if a tile is a road or road bridge (vehicles can traverse both)\n// Rail bridges are NOT valid for cars\nexport function isRoadTile(gridData: Tile[][], gridSizeValue: number, x: number, y: number): boolean {\n  if (x < 0 || y < 0 || x >= gridSizeValue || y >= gridSizeValue) return false;\n  const tile = gridData[y][x];\n  const type = tile.building.type;\n  // Road bridges are valid, rail bridges are not\n  if (type === 'bridge') {\n    return tile.building.bridgeTrackType !== 'rail';\n  }\n  return type === 'road';\n}\n\n// Check if a car can enter a tile from a given direction\n// Bridges can only be entered along their orientation (ns bridges: north/south, ew bridges: east/west)\nfunction canEnterTileFromDirection(gridData: Tile[][], gridSizeValue: number, x: number, y: number, direction: CarDirection): boolean {\n  if (x < 0 || y < 0 || x >= gridSizeValue || y >= gridSizeValue) return false;\n  const tile = gridData[y]?.[x];\n  if (!tile) return false;\n  \n  // If it's a bridge, check if the direction matches the bridge orientation\n  if (tile.building.type === 'bridge') {\n    // Rail bridges are not valid for cars\n    if (tile.building.bridgeTrackType === 'rail') return false;\n    \n    const orientation = tile.building.bridgeOrientation;\n    // ns bridges only allow north/south travel\n    if (orientation === 'ns' && (direction === 'north' || direction === 'south')) return true;\n    // ew bridges only allow east/west travel\n    if (orientation === 'ew' && (direction === 'east' || direction === 'west')) return true;\n    // Direction doesn't match bridge orientation - can't enter\n    return false;\n  }\n  \n  // Regular road tiles can be entered from any direction\n  return tile.building.type === 'road';\n}\n\n// Get available direction options from a tile\nexport function getDirectionOptions(gridData: Tile[][], gridSizeValue: number, x: number, y: number): CarDirection[] {\n  const options: CarDirection[] = [];\n  if (isRoadTile(gridData, gridSizeValue, x - 1, y)) options.push('north');\n  if (isRoadTile(gridData, gridSizeValue, x, y - 1)) options.push('east');\n  if (isRoadTile(gridData, gridSizeValue, x + 1, y)) options.push('south');\n  if (isRoadTile(gridData, gridSizeValue, x, y + 1)) options.push('west');\n  return options;\n}\n\n// Pick next direction for vehicle movement\n// On bridges, cars can only go straight (no turning)\n// Cars can only enter bridges from valid directions matching the bridge orientation\nexport function pickNextDirection(\n  previousDirection: CarDirection,\n  gridData: Tile[][],\n  gridSizeValue: number,\n  x: number,\n  y: number\n): CarDirection | null {\n  const options = getDirectionOptions(gridData, gridSizeValue, x, y);\n  if (options.length === 0) return null;\n  \n  // Check if current tile is a bridge - if so, only allow going straight\n  const currentTile = gridData[y]?.[x];\n  if (currentTile?.building.type === 'bridge') {\n    // On a bridge, only continue in the same direction (no turning)\n    if (options.includes(previousDirection)) {\n      return previousDirection;\n    }\n    // If we can't continue straight, fall back to normal behavior\n  }\n  \n  // Filter out directions that would enter a bridge from an invalid angle\n  // For each direction, check if the target tile can be entered from that direction\n  const directionOffsets: Record<CarDirection, { dx: number; dy: number }> = {\n    'north': { dx: -1, dy: 0 },\n    'south': { dx: 1, dy: 0 },\n    'east': { dx: 0, dy: -1 },\n    'west': { dx: 0, dy: 1 },\n  };\n  \n  const validOptions = options.filter(dir => {\n    const offset = directionOffsets[dir];\n    const targetX = x + offset.dx;\n    const targetY = y + offset.dy;\n    return canEnterTileFromDirection(gridData, gridSizeValue, targetX, targetY, dir);\n  });\n  \n  if (validOptions.length === 0) return null;\n  \n  const incoming = getOppositeDirection(previousDirection);\n  const filtered = validOptions.filter(dir => dir !== incoming);\n  const pool = filtered.length > 0 ? filtered : validOptions;\n  return pool[Math.floor(Math.random() * pool.length)];\n}\n\n// PERF: Pre-allocated arrays for findNearestRoadToBuilding BFS\nconst ROAD_BFS_MAX_SIZE = 4096; // Max tiles to check\nconst ROAD_BFS_QUEUE_X = new Int16Array(ROAD_BFS_MAX_SIZE);\nconst ROAD_BFS_QUEUE_Y = new Int16Array(ROAD_BFS_MAX_SIZE);\nconst ROAD_BFS_QUEUE_DIST = new Int16Array(ROAD_BFS_MAX_SIZE);\nconst ROAD_BFS_VISITED = new Uint8Array(256 * 256); // Max 256x256 grid\n\n// Direction offsets for 8-directional search\nconst ADJ_DX = [-1, 1, 0, 0, -1, -1, 1, 1];\nconst ADJ_DY = [0, 0, -1, 1, -1, 1, -1, 1];\n\n// Find the nearest road tile adjacent to a building\n// PERF: Uses pre-allocated typed arrays and numeric visited keys\nexport function findNearestRoadToBuilding(\n  gridData: Tile[][],\n  gridSizeValue: number,\n  buildingX: number,\n  buildingY: number\n): { x: number; y: number } | null {\n  // Check adjacent tiles first (distance 1) - including diagonals\n  for (let d = 0; d < 8; d++) {\n    const nx = buildingX + ADJ_DX[d];\n    const ny = buildingY + ADJ_DY[d];\n    if (isRoadTile(gridData, gridSizeValue, nx, ny)) {\n      return { x: nx, y: ny };\n    }\n  }\n  \n  // For larger grids or edge cases, use optimized BFS\n  const maxIdx = gridSizeValue * gridSizeValue;\n  if (maxIdx > ROAD_BFS_VISITED.length) {\n    // Fallback to string-based Set for very large grids\n    return findNearestRoadLegacy(gridData, gridSizeValue, buildingX, buildingY);\n  }\n  \n  // Clear visited array for the area we need\n  for (let i = 0; i < maxIdx; i++) {\n    ROAD_BFS_VISITED[i] = 0;\n  }\n  \n  // BFS using pre-allocated arrays\n  let queueHead = 0;\n  let queueTail = 1;\n  ROAD_BFS_QUEUE_X[0] = buildingX;\n  ROAD_BFS_QUEUE_Y[0] = buildingY;\n  ROAD_BFS_QUEUE_DIST[0] = 0;\n  ROAD_BFS_VISITED[buildingY * gridSizeValue + buildingX] = 1;\n  \n  while (queueHead < queueTail && queueTail < ROAD_BFS_MAX_SIZE) {\n    const cx = ROAD_BFS_QUEUE_X[queueHead];\n    const cy = ROAD_BFS_QUEUE_Y[queueHead];\n    const dist = ROAD_BFS_QUEUE_DIST[queueHead];\n    queueHead++;\n    \n    if (dist > 20) break; // Max search distance\n    \n    for (let d = 0; d < 8; d++) {\n      const nx = cx + ADJ_DX[d];\n      const ny = cy + ADJ_DY[d];\n      \n      if (nx < 0 || ny < 0 || nx >= gridSizeValue || ny >= gridSizeValue) continue;\n      \n      const visitedIdx = ny * gridSizeValue + nx;\n      if (ROAD_BFS_VISITED[visitedIdx]) continue;\n      ROAD_BFS_VISITED[visitedIdx] = 1;\n      \n      if (isRoadTile(gridData, gridSizeValue, nx, ny)) {\n        return { x: nx, y: ny };\n      }\n      \n      ROAD_BFS_QUEUE_X[queueTail] = nx;\n      ROAD_BFS_QUEUE_Y[queueTail] = ny;\n      ROAD_BFS_QUEUE_DIST[queueTail] = dist + 1;\n      queueTail++;\n    }\n  }\n  \n  return null;\n}\n\n// Legacy fallback for very large grids\nfunction findNearestRoadLegacy(\n  gridData: Tile[][],\n  gridSizeValue: number,\n  buildingX: number,\n  buildingY: number\n): { x: number; y: number } | null {\n  const queue: { x: number; y: number; dist: number }[] = [{ x: buildingX, y: buildingY, dist: 0 }];\n  const visited = new Set<number>(); // PERF: Use numeric keys\n  visited.add(buildingY * gridSizeValue + buildingX);\n  \n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    if (current.dist > 20) break;\n    \n    for (let d = 0; d < 8; d++) {\n      const nx = current.x + ADJ_DX[d];\n      const ny = current.y + ADJ_DY[d];\n      \n      if (nx < 0 || ny < 0 || nx >= gridSizeValue || ny >= gridSizeValue) continue;\n      \n      const key = ny * gridSizeValue + nx;\n      if (visited.has(key)) continue;\n      visited.add(key);\n      \n      if (isRoadTile(gridData, gridSizeValue, nx, ny)) {\n        return { x: nx, y: ny };\n      }\n      \n      queue.push({ x: nx, y: ny, dist: current.dist + 1 });\n    }\n  }\n  \n  return null;\n}\n\n// BFS pathfinding on road network - finds path from start to a tile adjacent to target\n// PERF: Uses pre-allocated typed arrays to avoid GC pressure from path copying\nexport function findPathOnRoads(\n  gridData: Tile[][],\n  gridSizeValue: number,\n  startX: number,\n  startY: number,\n  targetX: number,\n  targetY: number\n): { x: number; y: number }[] | null {\n  // Find the nearest road tile to the target (since buildings aren't on roads)\n  const targetRoad = findNearestRoadToBuilding(gridData, gridSizeValue, targetX, targetY);\n  if (!targetRoad) return null;\n  \n  // Find the nearest road tile to the start (station)\n  const startRoad = findNearestRoadToBuilding(gridData, gridSizeValue, startX, startY);\n  if (!startRoad) return null;\n  \n  // If start and target roads are the same, return a simple path\n  if (startRoad.x === targetRoad.x && startRoad.y === targetRoad.y) {\n    return [{ x: startRoad.x, y: startRoad.y }];\n  }\n  \n  // PERF: Clear visited array only for the area we need (faster than full clear)\n  // Using numeric keys: index = y * gridSize + x\n  const maxIdx = gridSizeValue * gridSizeValue;\n  if (maxIdx > BFS_VISITED.length) {\n    // Fallback to old method for very large grids\n    return findPathOnRoadsLegacy(gridData, gridSizeValue, startRoad, targetRoad);\n  }\n  \n  // Clear visited (only the portion we'll use)\n  for (let i = 0; i < maxIdx; i++) {\n    BFS_VISITED[i] = 0;\n  }\n  \n  // BFS using pre-allocated arrays\n  let queueHead = 0;\n  let queueTail = 1;\n  BFS_QUEUE_X[0] = startRoad.x;\n  BFS_QUEUE_Y[0] = startRoad.y;\n  BFS_PARENT_X[0] = -1; // -1 indicates start node\n  BFS_PARENT_Y[0] = -1;\n  BFS_VISITED[startRoad.y * gridSizeValue + startRoad.x] = 1;\n  \n  // Direction offsets\n  const DX = [-1, 1, 0, 0];\n  const DY = [0, 0, -1, 1];\n  \n  let foundIdx = -1;\n  \n  while (queueHead < queueTail && queueTail < MAX_PATH_LENGTH) {\n    const cx = BFS_QUEUE_X[queueHead];\n    const cy = BFS_QUEUE_Y[queueHead];\n    const currentIdx = queueHead;\n    queueHead++;\n    \n    // Check if we reached the target road\n    if (cx === targetRoad.x && cy === targetRoad.y) {\n      foundIdx = currentIdx;\n      break;\n    }\n    \n    for (let d = 0; d < 4; d++) {\n      const nx = cx + DX[d];\n      const ny = cy + DY[d];\n      \n      if (nx < 0 || ny < 0 || nx >= gridSizeValue || ny >= gridSizeValue) continue;\n      \n      const visitedIdx = ny * gridSizeValue + nx;\n      if (BFS_VISITED[visitedIdx]) continue;\n      if (!isRoadTile(gridData, gridSizeValue, nx, ny)) continue;\n      \n      BFS_VISITED[visitedIdx] = 1;\n      BFS_QUEUE_X[queueTail] = nx;\n      BFS_QUEUE_Y[queueTail] = ny;\n      BFS_PARENT_X[queueTail] = cx;\n      BFS_PARENT_Y[queueTail] = cy;\n      queueTail++;\n    }\n  }\n  \n  if (foundIdx === -1) return null;\n  \n  // Reconstruct path by walking back through parents\n  const pathReverse: { x: number; y: number }[] = [];\n  let idx = foundIdx;\n  \n  // Walk back through the BFS tree to reconstruct path\n  while (idx >= 0) {\n    pathReverse.push({ x: BFS_QUEUE_X[idx], y: BFS_QUEUE_Y[idx] });\n    \n    // Find parent index by searching queue\n    const px = BFS_PARENT_X[idx];\n    const py = BFS_PARENT_Y[idx];\n    \n    if (px === -1) break; // Reached start\n    \n    // Search backwards for parent position in queue\n    let parentIdx = -1;\n    for (let i = idx - 1; i >= 0; i--) {\n      if (BFS_QUEUE_X[i] === px && BFS_QUEUE_Y[i] === py) {\n        parentIdx = i;\n        break;\n      }\n    }\n    idx = parentIdx;\n  }\n  \n  // Reverse to get path from start to target\n  return pathReverse.reverse();\n}\n\n// Legacy implementation for very large grids (fallback)\nfunction findPathOnRoadsLegacy(\n  gridData: Tile[][],\n  gridSizeValue: number,\n  startRoad: { x: number; y: number },\n  targetRoad: { x: number; y: number }\n): { x: number; y: number }[] | null {\n  const queue: { x: number; y: number; path: { x: number; y: number }[] }[] = [\n    { x: startRoad.x, y: startRoad.y, path: [{ x: startRoad.x, y: startRoad.y }] }\n  ];\n  const visited = new Set<string>();\n  visited.add(`${startRoad.x},${startRoad.y}`);\n  \n  const directions = [\n    { dx: -1, dy: 0 },\n    { dx: 1, dy: 0 },\n    { dx: 0, dy: -1 },\n    { dx: 0, dy: 1 },\n  ];\n  \n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    \n    if (current.x === targetRoad.x && current.y === targetRoad.y) {\n      return current.path;\n    }\n    \n    for (const { dx, dy } of directions) {\n      const nx = current.x + dx;\n      const ny = current.y + dy;\n      const key = `${nx},${ny}`;\n      \n      if (nx < 0 || ny < 0 || nx >= gridSizeValue || ny >= gridSizeValue) continue;\n      if (visited.has(key)) continue;\n      if (!isRoadTile(gridData, gridSizeValue, nx, ny)) continue;\n      \n      visited.add(key);\n      queue.push({\n        x: nx,\n        y: ny,\n        path: [...current.path, { x: nx, y: ny }],\n      });\n    }\n  }\n  \n  return null;\n}\n\n// Get direction from current tile to next tile\nexport function getDirectionToTile(fromX: number, fromY: number, toX: number, toY: number): CarDirection | null {\n  const dx = toX - fromX;\n  const dy = toY - fromY;\n  \n  if (dx === -1 && dy === 0) return 'north';\n  if (dx === 1 && dy === 0) return 'south';\n  if (dx === 0 && dy === -1) return 'east';\n  if (dx === 0 && dy === 1) return 'west';\n  \n  return null;\n}\n\n// Convert grid coordinates to screen coordinates (isometric)\nexport function gridToScreen(x: number, y: number, offsetX: number, offsetY: number): { screenX: number; screenY: number } {\n  const screenX = (x - y) * (TILE_WIDTH / 2) + offsetX;\n  const screenY = (x + y) * (TILE_HEIGHT / 2) + offsetY;\n  return { screenX, screenY };\n}\n\n// Convert screen coordinates to grid coordinates\nexport function screenToGrid(screenX: number, screenY: number, offsetX: number, offsetY: number): { gridX: number; gridY: number } {\n  // Adjust for the fact that tile centers are offset by half a tile from gridToScreen coordinates\n  // gridToScreen returns the top-left corner of the bounding box, but the visual center of the\n  // diamond tile is at (screenX + TILE_WIDTH/2, screenY + TILE_HEIGHT/2)\n  const adjustedX = screenX - offsetX - TILE_WIDTH / 2;\n  const adjustedY = screenY - offsetY - TILE_HEIGHT / 2;\n  \n  const gridX = (adjustedX / (TILE_WIDTH / 2) + adjustedY / (TILE_HEIGHT / 2)) / 2;\n  const gridY = (adjustedY / (TILE_HEIGHT / 2) - adjustedX / (TILE_WIDTH / 2)) / 2;\n  \n  // Use Math.round for accurate tile selection - this gives us the tile whose center is closest\n  return { gridX: Math.round(gridX), gridY: Math.round(gridY) };\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1639, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethanchen/Projects/hackajohn/src/components/RoomPlanner.tsx"],"sourcesContent":["'use client';\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { gridToScreen, screenToGrid } from '@isocity/components/game/utils';\nimport { TILE_HEIGHT, TILE_WIDTH } from '@isocity/components/game/types';\n\ntype Tool = 'floor' | 'erase' | 'furniture';\n\ntype FurnitureType = 'sofa' | 'bed' | 'table' | 'chair' | 'plant';\n\ntype RoomType = 'bedroom' | 'living_room' | 'kitchen' | 'bathroom' | 'hallway' | 'office';\n\ntype Room = {\n  type: RoomType;\n  label: string;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n};\n\ntype FurnitureItem = {\n  id: string;\n  type: FurnitureType;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  rotation: 0 | 90;\n};\n\ntype FurniturePaletteItem = {\n  label: string;\n  w: number;\n  h: number;\n  height: number;\n  top: string;\n  side: string;\n  front: string;\n  swatch: string;\n};\n\nconst FURNITURE_CATALOG: Record<FurnitureType, FurniturePaletteItem> = {\n  sofa: {\n    label: 'Sofa',\n    w: 2,\n    h: 1,\n    height: 18,\n    top: '#e4b49f',\n    side: '#c78672',\n    front: '#b0705d',\n    swatch: '#d59d88'\n  },\n  bed: {\n    label: 'Bed',\n    w: 2,\n    h: 2,\n    height: 22,\n    top: '#eadfcd',\n    side: '#cbbda6',\n    front: '#b6a58c',\n    swatch: '#d8cbb6'\n  },\n  table: {\n    label: 'Table',\n    w: 2,\n    h: 1,\n    height: 14,\n    top: '#d6c08f',\n    side: '#b59e6c',\n    front: '#a38a5b',\n    swatch: '#c9b27c'\n  },\n  chair: {\n    label: 'Chair',\n    w: 1,\n    h: 1,\n    height: 14,\n    top: '#9bd3c8',\n    side: '#6fb7aa',\n    front: '#5fa296',\n    swatch: '#87c5ba'\n  },\n  plant: {\n    label: 'Plant',\n    w: 1,\n    h: 1,\n    height: 20,\n    top: '#9ccc75',\n    side: '#7faa5b',\n    front: '#6f914e',\n    swatch: '#86b764'\n  }\n};\n\nconst DEFAULT_WIDTH = 12;\nconst DEFAULT_HEIGHT = 8;\n\nconst ROOM_COLORS: Record<RoomType, { fill: string; label: string }> = {\n  bedroom: { fill: 'rgba(86, 140, 214, 0.65)', label: 'rgba(86, 140, 214, 0.9)' },\n  living_room: { fill: 'rgba(120, 201, 172, 0.6)', label: 'rgba(120, 201, 172, 0.9)' },\n  kitchen: { fill: 'rgba(242, 192, 107, 0.7)', label: 'rgba(242, 192, 107, 0.95)' },\n  bathroom: { fill: 'rgba(109, 178, 207, 0.65)', label: 'rgba(109, 178, 207, 0.95)' },\n  hallway: { fill: 'rgba(195, 164, 122, 0.6)', label: 'rgba(195, 164, 122, 0.9)' },\n  office: { fill: 'rgba(135, 206, 125, 0.6)', label: 'rgba(135, 206, 125, 0.9)' }\n};\n\nconst MOCK_ROOMS: Room[] = [\n  { type: 'living_room', label: 'Living Room', x: 0, y: 0, w: 5, h: 4 },\n  { type: 'kitchen', label: 'Kitchen', x: 5, y: 0, w: 3, h: 3 },\n  { type: 'hallway', label: 'Hallway', x: 8, y: 0, w: 4, h: 8 },\n  { type: 'bedroom', label: 'Bedroom', x: 0, y: 4, w: 5, h: 4 },\n  { type: 'bathroom', label: 'Bath', x: 5, y: 3, w: 3, h: 2 },\n  { type: 'office', label: 'Office', x: 5, y: 5, w: 3, h: 3 }\n];\n\nfunction createFloor(width: number, height: number): boolean[][] {\n  return Array.from({ length: height }, () => Array.from({ length: width }, () => true));\n}\n\nfunction findRoomAt(rooms: Room[], x: number, y: number): Room | null {\n  for (const room of rooms) {\n    if (x >= room.x && x < room.x + room.w && y >= room.y && y < room.y + room.h) {\n      return room;\n    }\n  }\n  return null;\n}\n\nfunction createId(): string {\n  if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {\n    return crypto.randomUUID();\n  }\n  return `item-${Date.now()}-${Math.random().toString(16).slice(2)}`;\n}\n\nfunction buildItem(type: FurnitureType, x: number, y: number, rotation: 0 | 90): FurnitureItem {\n  const base = FURNITURE_CATALOG[type];\n  const w = rotation === 90 ? base.h : base.w;\n  const h = rotation === 90 ? base.w : base.h;\n  return { id: createId(), type, x, y, w, h, rotation };\n}\n\nfunction itemCells(item: FurnitureItem): Array<{ x: number; y: number }> {\n  const cells: Array<{ x: number; y: number }> = [];\n  for (let dy = 0; dy < item.h; dy += 1) {\n    for (let dx = 0; dx < item.w; dx += 1) {\n      cells.push({ x: item.x + dx, y: item.y + dy });\n    }\n  }\n  return cells;\n}\n\nfunction isFloorTile(grid: boolean[][], x: number, y: number): boolean {\n  return grid[y]?.[x] ?? false;\n}\n\nfunction canPlaceItem(\n  grid: boolean[][],\n  items: FurnitureItem[],\n  candidate: FurnitureItem,\n  ignoreId?: string\n): boolean {\n  for (const cell of itemCells(candidate)) {\n    if (!isFloorTile(grid, cell.x, cell.y)) return false;\n    if (cell.x < 0 || cell.y < 0) return false;\n  }\n  for (const item of items) {\n    if (ignoreId && item.id === ignoreId) continue;\n    for (const cell of itemCells(item)) {\n      if (\n        cell.x >= candidate.x &&\n        cell.x < candidate.x + candidate.w &&\n        cell.y >= candidate.y &&\n        cell.y < candidate.y + candidate.h\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\nfunction findItemAt(items: FurnitureItem[], gridX: number, gridY: number): FurnitureItem | null {\n  const sorted = [...items].sort((a, b) => (a.x + a.y) - (b.x + b.y));\n  for (let i = sorted.length - 1; i >= 0; i -= 1) {\n    const item = sorted[i];\n    if (gridX >= item.x && gridX < item.x + item.w && gridY >= item.y && gridY < item.y + item.h) {\n      return item;\n    }\n  }\n  return null;\n}\n\nfunction sanitizeItems(grid: boolean[][], items: FurnitureItem[]): FurnitureItem[] {\n  return items.filter((item) => {\n    for (const cell of itemCells(item)) {\n      if (!isFloorTile(grid, cell.x, cell.y)) return false;\n    }\n    return true;\n  });\n}\n\nexport default function RoomPlanner() {\n  const isoCanvasRef = useRef<HTMLCanvasElement | null>(null);\n  const [grid, setGrid] = useState<boolean[][]>(() => createFloor(DEFAULT_WIDTH, DEFAULT_HEIGHT));\n  const [items, setItems] = useState<FurnitureItem[]>(() => [\n    buildItem('sofa', 2, 2, 0),\n    buildItem('table', 5, 3, 0),\n    buildItem('bed', 7, 2, 0),\n    buildItem('plant', 1, 5, 0)\n  ]);\n  const [tool, setTool] = useState<Tool>('floor');\n  const [activeFurniture, setActiveFurniture] = useState<FurnitureType>('sofa');\n  const [rotation, setRotation] = useState<0 | 90>(0);\n  const [status, setStatus] = useState<string>('Drag furniture in the isometric view to move it.');\n  const [selectedItemId, setSelectedItemId] = useState<string | null>(null);\n  const [rooms] = useState<Room[]>(() => MOCK_ROOMS);\n\n  const gridWidth = grid[0]?.length ?? 0;\n  const gridHeight = grid.length;\n  const roomCount = rooms.length;\n  const handleDownload = useCallback(() => {\n    const canvas = isoCanvasRef.current;\n    if (!canvas) return;\n    const url = canvas.toDataURL('image/png');\n    const link = document.createElement('a');\n    link.download = 'iso-room.png';\n    link.href = url;\n    link.click();\n  }, []);\n\n  const occupancy = useMemo(() => {\n    const map = new Map<string, FurnitureType>();\n    for (const item of items) {\n      for (const cell of itemCells(item)) {\n        map.set(`${cell.x},${cell.y}`, item.type);\n      }\n    }\n    return map;\n  }, [items]);\n\n  const handleCellClick = useCallback((x: number, y: number) => {\n    if (tool === 'floor' || tool === 'erase') {\n      setGrid((prev) => {\n        const next = prev.map((row, rowIndex) =>\n          row.map((cell, colIndex) => {\n            if (rowIndex !== y || colIndex !== x) return cell;\n            return tool === 'floor';\n          })\n        );\n        setItems((current) => sanitizeItems(next, current));\n        return next;\n      });\n      return;\n    }\n\n    if (tool === 'furniture') {\n      const candidate = buildItem(activeFurniture, x, y, rotation);\n      if (canPlaceItem(grid, items, candidate)) {\n        setItems((prev) => [...prev, candidate]);\n        setSelectedItemId(candidate.id);\n        setStatus('Placed furniture. Drag to move.');\n      } else {\n        setStatus('Cannot place there. Try another tile.');\n      }\n    }\n  }, [activeFurniture, grid, items, rotation, tool]);\n\n  const resetScene = useCallback(() => {\n    const nextGrid = createFloor(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    setGrid(nextGrid);\n    setItems([\n      buildItem('sofa', 2, 2, 0),\n      buildItem('table', 5, 3, 0),\n      buildItem('bed', 7, 2, 0),\n      buildItem('plant', 1, 5, 0)\n    ]);\n    setStatus('Reset to a clean, playable scene.');\n  }, []);\n\n  const clearFurniture = useCallback(() => {\n    setItems([]);\n    setSelectedItemId(null);\n    setStatus('Cleared all furniture.');\n  }, []);\n\n  return (\n    <>\n      <section className=\"planner\">\n        <div className=\"canvas-layer\">\n          <IsoRoomCanvas\n            grid={grid}\n            items={items}\n            rooms={rooms}\n            onMoveItem={(id, nextX, nextY) => {\n              setItems((prev) =>\n                prev.map((item) =>\n                  item.id === id\n                    ? { ...item, x: nextX, y: nextY }\n                    : item\n                )\n              );\n            }}\n            selectedItemId={selectedItemId}\n            onSelectItem={setSelectedItemId}\n            canvasRef={isoCanvasRef}\n          />\n        </div>\n\n        <div className=\"hud\">\n          <div className=\"hud-top\">\n            <button className=\"hud-button\" type=\"button\">Pause</button>\n            <button className=\"hud-button secondary\" type=\"button\">Play</button>\n          </div>\n\n          <div className=\"hud-right\">\n            <div className=\"hud-panel\">\n              <h2>Floor Plan</h2>\n              <div className=\"tool-row\">\n                <button\n                  className={`tool-button ${tool === 'floor' ? 'active' : ''}`}\n                  onClick={() => setTool('floor')}\n                  type=\"button\"\n                >\n                  Add Floor\n                </button>\n                <button\n                  className={`tool-button ${tool === 'erase' ? 'active' : ''}`}\n                  onClick={() => setTool('erase')}\n                  type=\"button\"\n                >\n                  Erase\n                </button>\n                <button\n                  className={`tool-button ${tool === 'furniture' ? 'active' : ''}`}\n                  onClick={() => setTool('furniture')}\n                  type=\"button\"\n                >\n                  Place Furniture\n                </button>\n              </div>\n\n              <div className=\"furniture-list\">\n                {Object.entries(FURNITURE_CATALOG).map(([key, data]) => (\n                  <button\n                    key={key}\n                    type=\"button\"\n                    className={`furniture-card ${activeFurniture === key ? 'active' : ''}`}\n                    onClick={() => {\n                      setActiveFurniture(key as FurnitureType);\n                      setTool('furniture');\n                    }}\n                  >\n                    <div className=\"furniture-swatch\" style={{ background: data.swatch }} />\n                    <strong>{data.label}</strong>\n                    <div className=\"note\">{data.w}x{data.h} tiles</div>\n                  </button>\n                ))}\n              </div>\n\n              <div className=\"tool-row\">\n                <button\n                  className=\"tool-button\"\n                  onClick={() => setRotation((prev) => (prev === 0 ? 90 : 0))}\n                  type=\"button\"\n                >\n                  Rotate {rotation === 0 ? '0°' : '90°'}\n                </button>\n              </div>\n\n              <div\n                className=\"grid\"\n                style={{ gridTemplateColumns: `repeat(${gridWidth}, 24px)` }}\n              >\n                {grid.map((row, y) =>\n                  row.map((cell, x) => {\n                    const key = `${x},${y}`;\n                    const itemType = occupancy.get(key);\n                    return (\n                      <button\n                        key={key}\n                        type=\"button\"\n                        className={`grid-cell ${cell ? 'floor' : 'blocked'}`}\n                        onClick={() => handleCellClick(x, y)}\n                        title={cell ? 'Floor' : 'Empty'}\n                        style={\n                          itemType\n                            ? { background: FURNITURE_CATALOG[itemType].swatch, color: '#0b0f14' }\n                            : undefined\n                        }\n                      >\n                        {itemType ? itemType[0].toUpperCase() : ''}\n                      </button>\n                    );\n                  })\n                )}\n              </div>\n\n              <div className=\"legend\">\n                <span><i style={{ background: 'rgba(108, 212, 197, 0.6)' }} /> Floor</span>\n                <span><i style={{ background: 'rgba(224, 122, 95, 0.5)' }} /> Empty</span>\n                <span><i style={{ background: 'var(--accent)' }} /> Furniture</span>\n              </div>\n            </div>\n\n            <div className=\"hud-panel\">\n              <h2>Actions</h2>\n              <div className=\"actions\">\n                <button className=\"action-button primary\" onClick={resetScene} type=\"button\">Reset Scene</button>\n                <button className=\"action-button\" onClick={clearFurniture} type=\"button\">Clear Furniture</button>\n                <button className=\"action-button primary\" onClick={handleDownload} type=\"button\">Download PNG</button>\n              </div>\n              <div className=\"status\">{status} Rooms: {roomCount}</div>\n              <p className=\"note\">Tip: click any tile while in Place Furniture mode to drop items. Drag items around in the isometric view.</p>\n            </div>\n          </div>\n\n          <div className=\"hud-bottom\">\n            <div className=\"hud-bar\">\n              <span className=\"hud-title\">Iso Room Planner</span>\n              <span>Rooms: {roomCount}</span>\n            </div>\n          </div>\n        </div>\n      </section>\n    </>\n  );\n}\n\ntype IsoRoomCanvasProps = {\n  grid: boolean[][];\n  items: FurnitureItem[];\n  rooms: Room[];\n  onMoveItem: (id: string, x: number, y: number) => void;\n  selectedItemId: string | null;\n  onSelectItem: (id: string | null) => void;\n  canvasRef?: React.RefObject<HTMLCanvasElement | null>;\n};\n\nfunction IsoRoomCanvas({ grid, items, rooms, onMoveItem, selectedItemId, onSelectItem, canvasRef }: IsoRoomCanvasProps) {\n  const internalCanvasRef = useRef<HTMLCanvasElement | null>(null);\n  const resolvedCanvasRef = canvasRef ?? internalCanvasRef;\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const offsetRef = useRef({ x: 0, y: 0 });\n  const dragRef = useRef<{ id: string; offsetX: number; offsetY: number } | null>(null);\n  const panRef = useRef<{ startX: number; startY: number; baseX: number; baseY: number } | null>(null);\n  const [panOffset, setPanOffset] = useState({ x: 0, y: 0 });\n  const [canvasSize, setCanvasSize] = useState({ width: 600, height: 520 });\n\n  const gridWidth = grid[0]?.length ?? 0;\n  const gridHeight = grid.length;\n\n  useEffect(() => {\n    if (!containerRef.current) return;\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const { width, height } = entry.contentRect;\n        setCanvasSize({ width, height });\n      }\n    });\n    observer.observe(containerRef.current);\n    return () => observer.disconnect();\n  }, []);\n\n  const drawScene = useCallback(() => {\n    const canvas = resolvedCanvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = canvasSize.width * dpr;\n    canvas.height = canvasSize.height * dpr;\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);\n\n    const wallHeight = 42;\n    const corners = [\n      gridToScreen(0, 0, 0, 0),\n      gridToScreen(gridWidth - 1, 0, 0, 0),\n      gridToScreen(0, gridHeight - 1, 0, 0),\n      gridToScreen(gridWidth - 1, gridHeight - 1, 0, 0)\n    ];\n\n    const minX = Math.min(...corners.map((c) => c.screenX));\n    const maxX = Math.max(...corners.map((c) => c.screenX + TILE_WIDTH));\n    const minY = Math.min(...corners.map((c) => c.screenY));\n    const maxY = Math.max(...corners.map((c) => c.screenY + TILE_HEIGHT + wallHeight));\n\n    const roomWidth = maxX - minX;\n    const roomHeight = maxY - minY;\n\n    const offsetX = (canvasSize.width - roomWidth) / 2 - minX + panOffset.x;\n    const offsetY = (canvasSize.height - roomHeight) / 2 - minY + 24 + panOffset.y;\n    offsetRef.current = { x: offsetX, y: offsetY };\n\n    const drawDiamond = (x: number, y: number, fill: string, stroke?: string) => {\n      ctx.beginPath();\n      ctx.moveTo(x + TILE_WIDTH / 2, y);\n      ctx.lineTo(x + TILE_WIDTH, y + TILE_HEIGHT / 2);\n      ctx.lineTo(x + TILE_WIDTH / 2, y + TILE_HEIGHT);\n      ctx.lineTo(x, y + TILE_HEIGHT / 2);\n      ctx.closePath();\n      ctx.fillStyle = fill;\n      ctx.fill();\n      if (stroke) {\n        ctx.strokeStyle = stroke;\n        ctx.lineWidth = 1;\n        ctx.stroke();\n      }\n    };\n\n    const drawLabelPill = (x: number, y: number, text: string, color: string) => {\n      ctx.save();\n      ctx.font = '600 12px \"Space Grotesk\", system-ui';\n      const paddingX = 10;\n      const paddingY = 6;\n      const metrics = ctx.measureText(text);\n      const width = metrics.width + paddingX * 2;\n      const height = 20 + paddingY;\n      const radius = 10;\n\n      const left = x - width / 2;\n      const top = y - height / 2;\n\n      ctx.beginPath();\n      ctx.moveTo(left + radius, top);\n      ctx.lineTo(left + width - radius, top);\n      ctx.quadraticCurveTo(left + width, top, left + width, top + radius);\n      ctx.lineTo(left + width, top + height - radius);\n      ctx.quadraticCurveTo(left + width, top + height, left + width - radius, top + height);\n      ctx.lineTo(left + radius, top + height);\n      ctx.quadraticCurveTo(left, top + height, left, top + height - radius);\n      ctx.lineTo(left, top + radius);\n      ctx.quadraticCurveTo(left, top, left + radius, top);\n      ctx.closePath();\n      ctx.fillStyle = color;\n      ctx.fill();\n\n      ctx.fillStyle = '#0b0f14';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(text, x, y + 1);\n      ctx.restore();\n    };\n\n    const drawNorthWall = (x: number, y: number) => {\n      const baseLeft = { x: x + TILE_WIDTH / 2, y };\n      const baseRight = { x: x + TILE_WIDTH, y: y + TILE_HEIGHT / 2 };\n      ctx.beginPath();\n      ctx.moveTo(baseLeft.x, baseLeft.y);\n      ctx.lineTo(baseRight.x, baseRight.y);\n      ctx.lineTo(baseRight.x, baseRight.y - wallHeight);\n      ctx.lineTo(baseLeft.x, baseLeft.y - wallHeight);\n      ctx.closePath();\n      ctx.fillStyle = 'rgba(222, 205, 178, 0.9)';\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(108, 95, 80, 0.5)';\n      ctx.stroke();\n    };\n\n    const drawWestWall = (x: number, y: number) => {\n      const baseLeft = { x, y: y + TILE_HEIGHT / 2 };\n      const baseRight = { x: x + TILE_WIDTH / 2, y };\n      ctx.beginPath();\n      ctx.moveTo(baseLeft.x, baseLeft.y);\n      ctx.lineTo(baseRight.x, baseRight.y);\n      ctx.lineTo(baseRight.x, baseRight.y - wallHeight);\n      ctx.lineTo(baseLeft.x, baseLeft.y - wallHeight);\n      ctx.closePath();\n      ctx.fillStyle = 'rgba(198, 180, 152, 0.9)';\n      ctx.fill();\n      ctx.strokeStyle = 'rgba(96, 84, 70, 0.5)';\n      ctx.stroke();\n    };\n\n    for (let y = 0; y < gridHeight; y += 1) {\n      for (let x = 0; x < gridWidth; x += 1) {\n        if (!isFloorTile(grid, x, y)) continue;\n        const room = findRoomAt(rooms, x, y);\n        const { screenX, screenY } = gridToScreen(x, y, offsetX, offsetY);\n        const fill = room ? ROOM_COLORS[room.type].fill : 'rgba(55, 77, 95, 0.75)';\n        drawDiamond(screenX, screenY, fill, 'rgba(36, 55, 70, 0.8)');\n      }\n    }\n\n    for (let y = 0; y < gridHeight; y += 1) {\n      for (let x = 0; x < gridWidth; x += 1) {\n        if (!isFloorTile(grid, x, y)) continue;\n        const { screenX, screenY } = gridToScreen(x, y, offsetX, offsetY);\n        if (!isFloorTile(grid, x, y - 1)) {\n          drawNorthWall(screenX, screenY);\n        }\n        if (!isFloorTile(grid, x - 1, y)) {\n          drawWestWall(screenX, screenY);\n        }\n      }\n    }\n\n    for (const room of rooms) {\n      const centerX = room.x + room.w / 2;\n      const centerY = room.y + room.h / 2;\n      const { screenX, screenY } = gridToScreen(centerX, centerY, offsetX, offsetY);\n      const labelX = screenX + TILE_WIDTH / 2;\n      const labelY = screenY + TILE_HEIGHT / 2 - 18;\n      drawLabelPill(labelX, labelY, room.label, ROOM_COLORS[room.type].label);\n    }\n\n    const sortedItems = [...items].sort((a, b) => (a.x + a.y) - (b.x + b.y));\n    for (const item of sortedItems) {\n      const palette = FURNITURE_CATALOG[item.type];\n      const height = palette.height;\n\n      const top = gridToScreen(item.x, item.y, offsetX, offsetY);\n      const right = gridToScreen(item.x + item.w, item.y, offsetX, offsetY);\n      const bottom = gridToScreen(item.x + item.w, item.y + item.h, offsetX, offsetY);\n      const left = gridToScreen(item.x, item.y + item.h, offsetX, offsetY);\n\n      const topPoint = { x: top.screenX + TILE_WIDTH / 2, y: top.screenY - height };\n      const rightPoint = { x: right.screenX + TILE_WIDTH / 2, y: right.screenY - height };\n      const bottomPoint = { x: bottom.screenX + TILE_WIDTH / 2, y: bottom.screenY - height };\n      const leftPoint = { x: left.screenX + TILE_WIDTH / 2, y: left.screenY - height };\n\n      ctx.beginPath();\n      ctx.moveTo(topPoint.x, topPoint.y);\n      ctx.lineTo(rightPoint.x, rightPoint.y);\n      ctx.lineTo(bottomPoint.x, bottomPoint.y);\n      ctx.lineTo(leftPoint.x, leftPoint.y);\n      ctx.closePath();\n      ctx.fillStyle = palette.top;\n      ctx.fill();\n\n      ctx.beginPath();\n      ctx.moveTo(leftPoint.x, leftPoint.y);\n      ctx.lineTo(bottomPoint.x, bottomPoint.y);\n      ctx.lineTo(bottomPoint.x, bottomPoint.y + height);\n      ctx.lineTo(leftPoint.x, leftPoint.y + height);\n      ctx.closePath();\n      ctx.fillStyle = palette.front;\n      ctx.fill();\n\n      ctx.beginPath();\n      ctx.moveTo(rightPoint.x, rightPoint.y);\n      ctx.lineTo(bottomPoint.x, bottomPoint.y);\n      ctx.lineTo(bottomPoint.x, bottomPoint.y + height);\n      ctx.lineTo(rightPoint.x, rightPoint.y + height);\n      ctx.closePath();\n      ctx.fillStyle = palette.side;\n      ctx.fill();\n\n      if (item.id === selectedItemId) {\n        ctx.beginPath();\n        ctx.moveTo(topPoint.x, topPoint.y);\n        ctx.lineTo(rightPoint.x, rightPoint.y);\n        ctx.lineTo(bottomPoint.x, bottomPoint.y);\n        ctx.lineTo(leftPoint.x, leftPoint.y);\n        ctx.closePath();\n        ctx.strokeStyle = 'rgba(242, 161, 84, 0.95)';\n        ctx.lineWidth = 2;\n        ctx.stroke();\n      }\n    }\n  }, [canvasSize, grid, gridHeight, gridWidth, items, rooms, selectedItemId, resolvedCanvasRef, panOffset]);\n\n  useEffect(() => {\n    drawScene();\n  }, [drawScene]);\n\n  const handlePointerDown = useCallback((event: React.PointerEvent<HTMLCanvasElement>) => {\n    const canvas = resolvedCanvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    const { gridX, gridY } = screenToGrid(x, y, offsetRef.current.x, offsetRef.current.y);\n\n    const item = findItemAt(items, gridX, gridY);\n    if (item) {\n      dragRef.current = { id: item.id, offsetX: gridX - item.x, offsetY: gridY - item.y };\n      onSelectItem(item.id);\n      panRef.current = null;\n    } else {\n      onSelectItem(null);\n      panRef.current = { startX: event.clientX, startY: event.clientY, baseX: panOffset.x, baseY: panOffset.y };\n    }\n  }, [items, onSelectItem, panOffset, resolvedCanvasRef]);\n\n  const handlePointerMove = useCallback((event: React.PointerEvent<HTMLCanvasElement>) => {\n    if (panRef.current) {\n      const dx = event.clientX - panRef.current.startX;\n      const dy = event.clientY - panRef.current.startY;\n      setPanOffset({ x: panRef.current.baseX + dx, y: panRef.current.baseY + dy });\n      return;\n    }\n    if (!dragRef.current) return;\n    const canvas = resolvedCanvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n    const x = event.clientX - rect.left;\n    const y = event.clientY - rect.top;\n    const { gridX, gridY } = screenToGrid(x, y, offsetRef.current.x, offsetRef.current.y);\n    const active = items.find((item) => item.id === dragRef.current?.id);\n    if (!active) return;\n\n    const nextX = clamp(gridX - dragRef.current.offsetX, 0, gridWidth - active.w);\n    const nextY = clamp(gridY - dragRef.current.offsetY, 0, gridHeight - active.h);\n    const candidate = { ...active, x: nextX, y: nextY };\n    if (canPlaceItem(grid, items, candidate, active.id)) {\n      onMoveItem(active.id, nextX, nextY);\n    }\n  }, [grid, gridHeight, gridWidth, items, onMoveItem, resolvedCanvasRef]);\n\n  const handlePointerUp = useCallback(() => {\n    dragRef.current = null;\n    panRef.current = null;\n  }, []);\n\n  return (\n    <div className=\"canvas-wrap\" ref={containerRef}>\n      <canvas\n        ref={resolvedCanvasRef}\n        onPointerDown={handlePointerDown}\n        onPointerMove={handlePointerMove}\n        onPointerUp={handlePointerUp}\n        onPointerLeave={handlePointerUp}\n      />\n    </div>\n  );\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2717, "column": 0}, "map": {"version":3,"sources":["file:///Users/ethanchen/Projects/hackajohn/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport RoomPlanner from '../components/RoomPlanner';\n\nexport default function Home() {\n  return (\n    <main className=\"app\">\n      <RoomPlanner />\n    </main>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AAFA;;;AAIe,SAAS;IACtB,qBACE,8OAAC;QAAK,WAAU;kBACd,cAAA,8OAAC,4IAAW;;;;;;;;;;AAGlB"}}]
}